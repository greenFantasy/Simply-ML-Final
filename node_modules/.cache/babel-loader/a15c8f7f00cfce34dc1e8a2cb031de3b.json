{"ast":null,"code":"import { isScaleFieldDef, vgField } from '../../channeldef';\nimport { fieldFilterExpression } from '../../predicate';\nimport { isSortArray } from '../../sort';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nimport { getDependentFields } from './expressions';\nexport class CalculateNode extends DataFlowNode {\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  static parseAllForSortIndex(parent, model) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n\n      if (isSortArray(fieldDef.sort)) {\n        const field = fieldDef.field,\n              timeUnit = fieldDef.timeUnit;\n        const sort = fieldDef.sort; // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n\n        const calculate = sort.map((sortValue, i) => {\n          return \"\".concat(fieldFilterExpression({\n            field,\n            timeUnit,\n            equal: sortValue\n          }), \" ? \").concat(i, \" : \");\n        }).join('') + sort.length;\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {\n            forAs: true\n          })\n        });\n      }\n    });\n    return parent;\n  }\n\n  producedFields() {\n    return new Set([this.transform.as]);\n  }\n\n  dependentFields() {\n    return this._dependentFields;\n  }\n\n  assemble() {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  hash() {\n    return \"Calculate \".concat(hash(this.transform));\n  }\n\n}\nexport function sortArrayIndexField(fieldDef, channel, opt) {\n  return vgField(fieldDef, Object.assign({\n    prefix: channel,\n    suffix: 'sort_index'\n  }, opt || {}));\n}","map":null,"metadata":{},"sourceType":"module"}