{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { COLUMN, FACET, ROW } from '../channel';\nimport { boxPlotNormalizer } from '../compositemark/boxplot';\nimport { errorBandNormalizer } from '../compositemark/errorband';\nimport { errorBarNormalizer } from '../compositemark/errorbar';\nimport { channelHasField } from '../encoding';\nimport * as log from '../log';\nimport { isFacetMapping } from '../spec/facet';\nimport { SpecMapper } from '../spec/map';\nimport { isUnitSpec } from '../spec/unit';\nimport { keys, omit } from '../util';\nimport { PathOverlayNormalizer } from './pathoverlay';\nimport { RangeStepNormalizer } from './rangestep';\nimport { RuleForRangedLineNormalizer } from './ruleforrangedline';\nexport class CoreNormalizer extends SpecMapper {\n  constructor() {\n    super(...arguments);\n    this.nonFacetUnitNormalizers = [boxPlotNormalizer, errorBarNormalizer, errorBandNormalizer, new PathOverlayNormalizer(), new RuleForRangedLineNormalizer(), new RangeStepNormalizer()];\n  }\n\n  map(spec, params) {\n    // Special handling for a faceted unit spec as it can return a facet spec, not just a layer or unit spec like a normal unit spec.\n    if (isUnitSpec(spec)) {\n      const hasRow = channelHasField(spec.encoding, ROW);\n      const hasColumn = channelHasField(spec.encoding, COLUMN);\n      const hasFacet = channelHasField(spec.encoding, FACET);\n\n      if (hasRow || hasColumn || hasFacet) {\n        return this.mapFacetedUnit(spec, params);\n      }\n    }\n\n    return super.map(spec, params);\n  } // This is for normalizing non-facet unit\n\n\n  mapUnit(spec, params) {\n    const parentEncoding = params.parentEncoding,\n          parentProjection = params.parentProjection;\n\n    if (parentEncoding || parentProjection) {\n      return this.mapUnitWithParentEncodingOrProjection(spec, params);\n    }\n\n    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);\n\n    for (const unitNormalizer of this.nonFacetUnitNormalizers) {\n      if (unitNormalizer.hasMatchingType(spec, params.config)) {\n        return unitNormalizer.run(spec, params, normalizeLayerOrUnit);\n      }\n    }\n\n    return spec;\n  }\n\n  mapRepeat(spec, params) {\n    const _spec = spec,\n          repeat = _spec.repeat;\n\n    if (!isArray(repeat) && spec.columns) {\n      // is repeat with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('repeat'));\n    }\n\n    return Object.assign(Object.assign({}, spec), {\n      spec: this.map(spec.spec, params)\n    });\n  }\n\n  mapFacet(spec, params) {\n    const _spec2 = spec,\n          facet = _spec2.facet;\n\n    if (isFacetMapping(facet) && spec.columns) {\n      // is facet with row/column\n      spec = omit(spec, ['columns']);\n      log.warn(log.message.columnsNotSupportByRowCol('facet'));\n    }\n\n    return super.mapFacet(spec, params);\n  }\n\n  mapUnitWithParentEncodingOrProjection(spec, params) {\n    const encoding = spec.encoding,\n          projection = spec.projection;\n    const parentEncoding = params.parentEncoding,\n          parentProjection = params.parentProjection,\n          config = params.config;\n    const mergedProjection = mergeProjection({\n      parentProjection,\n      projection\n    });\n    const mergedEncoding = mergeEncoding({\n      parentEncoding,\n      encoding\n    });\n    return this.mapUnit(Object.assign(Object.assign(Object.assign({}, spec), mergedProjection ? {\n      projection: mergedProjection\n    } : {}), mergedEncoding ? {\n      encoding: mergedEncoding\n    } : {}), {\n      config\n    });\n  }\n\n  mapFacetedUnit(spec, params) {\n    // New encoding in the inside spec should not contain row / column\n    // as row/column should be moved to facet\n    const _a = spec.encoding,\n          row = _a.row,\n          column = _a.column,\n          facet = _a.facet,\n          encoding = __rest(_a, [\"row\", \"column\", \"facet\"]); // Mark and encoding should be moved into the inner spec\n\n\n    const mark = spec.mark,\n          width = spec.width,\n          projection = spec.projection,\n          height = spec.height,\n          selection = spec.selection,\n          _ = spec.encoding,\n          outerSpec = __rest(spec, [\"mark\", \"width\", \"projection\", \"height\", \"selection\", \"encoding\"]);\n\n    const _this$getFacetMapping = this.getFacetMappingAndLayout({\n      row,\n      column,\n      facet\n    }),\n          facetMapping = _this$getFacetMapping.facetMapping,\n          layout = _this$getFacetMapping.layout;\n\n    return this.mapFacet(Object.assign(Object.assign(Object.assign({}, outerSpec), layout), {\n      // row / column has higher precedence than facet\n      facet: facetMapping,\n      spec: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, projection ? {\n        projection\n      } : {}), {\n        mark\n      }), width ? {\n        width\n      } : {}), height ? {\n        height\n      } : {}), {\n        encoding\n      }), selection ? {\n        selection\n      } : {})\n    }), params);\n  }\n\n  getFacetMappingAndLayout(facets) {\n    const row = facets.row,\n          column = facets.column,\n          facet = facets.facet;\n\n    if (row || column) {\n      if (facet) {\n        log.warn(log.message.facetChannelDropped([...(row ? [ROW] : []), ...(column ? [COLUMN] : [])]));\n      }\n\n      const facetMapping = {};\n      const layout = {};\n\n      for (const channel of [ROW, COLUMN]) {\n        const def = facets[channel];\n\n        if (def) {\n          const align = def.align,\n                center = def.center,\n                spacing = def.spacing,\n                columns = def.columns,\n                defWithoutLayout = __rest(def, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n          facetMapping[channel] = defWithoutLayout;\n\n          for (const prop of ['align', 'center', 'spacing']) {\n            if (def[prop] !== undefined) {\n              layout[prop] = layout[prop] || {};\n              layout[prop][channel] = def[prop];\n            }\n          }\n        }\n      }\n\n      return {\n        facetMapping,\n        layout\n      };\n    } else {\n      const align = facet.align,\n            center = facet.center,\n            spacing = facet.spacing,\n            columns = facet.columns,\n            facetMapping = __rest(facet, [\"align\", \"center\", \"spacing\", \"columns\"]);\n\n      return {\n        facetMapping,\n        layout: Object.assign(Object.assign(Object.assign(Object.assign({}, align ? {\n          align\n        } : {}), center ? {\n          center\n        } : {}), spacing ? {\n          spacing\n        } : {}), columns ? {\n          columns\n        } : {})\n      };\n    }\n  }\n\n  mapLayer(spec, _a) {\n    // Special handling for extended layer spec\n    var parentEncoding = _a.parentEncoding,\n        parentProjection = _a.parentProjection,\n        otherParams = __rest(_a, [\"parentEncoding\", \"parentProjection\"]);\n\n    const encoding = spec.encoding,\n          projection = spec.projection,\n          rest = __rest(spec, [\"encoding\", \"projection\"]);\n\n    const params = Object.assign(Object.assign({}, otherParams), {\n      parentEncoding: mergeEncoding({\n        parentEncoding,\n        encoding\n      }),\n      parentProjection: mergeProjection({\n        parentProjection,\n        projection\n      })\n    });\n    return super.mapLayer(rest, params);\n  }\n\n}\n\nfunction mergeEncoding(opt) {\n  const parentEncoding = opt.parentEncoding,\n        encoding = opt.encoding;\n\n  if (parentEncoding && encoding) {\n    const overriden = keys(parentEncoding).reduce((o, key) => {\n      if (encoding[key]) {\n        o.push(key);\n      }\n\n      return o;\n    }, []);\n\n    if (overriden.length > 0) {\n      log.warn(log.message.encodingOverridden(overriden));\n    }\n  }\n\n  const merged = Object.assign(Object.assign({}, parentEncoding || {}), encoding || {});\n  return keys(merged).length > 0 ? merged : undefined;\n}\n\nfunction mergeProjection(opt) {\n  const parentProjection = opt.parentProjection,\n        projection = opt.projection;\n\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({\n      parentProjection,\n      projection\n    }));\n  }\n\n  return projection || parentProjection;\n}","map":null,"metadata":{},"sourceType":"module"}