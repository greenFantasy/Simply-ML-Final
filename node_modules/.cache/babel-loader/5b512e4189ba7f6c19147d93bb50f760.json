{"ast":null,"code":"import * as log from '../log';\nimport { isLayerSpec, isUnitSpec } from '../spec';\nimport { keys } from '../util';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseLayerAxes } from './axis/parse';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { parseLayerLayoutSize } from './layoutsize/parse';\nimport { assembleLegends } from './legend/assemble';\nimport { Model } from './model';\nimport { assembleLayerSelectionMarks } from './selection/assemble';\nimport { UnitModel } from './unit';\nexport class LayerModel extends Model {\n  constructor(spec, parent, parentGivenName, parentGivenSize, repeater, config) {\n    super(spec, 'layer', parent, parentGivenName, config, repeater, spec.resolve, spec.view);\n    const layoutSize = Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n      width: spec.width\n    } : {}), spec.height ? {\n      height: spec.height\n    } : {});\n    this.children = spec.layer.map((layer, i) => {\n      if (isLayerSpec(layer)) {\n        return new LayerModel(layer, this, this.getName('layer_' + i), layoutSize, repeater, config);\n      } else if (isUnitSpec(layer)) {\n        return new UnitModel(layer, this, this.getName('layer_' + i), layoutSize, repeater, config);\n      }\n\n      throw new Error(log.message.invalidSpec(layer));\n    });\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  parseLayoutSize() {\n    parseLayerLayoutSize(this);\n  }\n\n  parseSelections() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n\n    for (const child of this.children) {\n      child.parseSelections();\n      keys(child.component.selection).forEach(key => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  parseAxesAndHeaders() {\n    parseLayerAxes(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  } // TODO: Support same named selections across children.\n\n\n  assembleSignals() {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleSignals());\n    }, assembleAxisSignals(this));\n  }\n\n  assembleLayoutSignals() {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, assembleLayoutSignals(this));\n  }\n\n  assembleSelectionData(data) {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  assembleTitle() {\n    let title = super.assembleTitle();\n\n    if (title) {\n      return title;\n    } // If title does not provide layer, look into children\n\n\n    for (const child of this.children) {\n      title = child.assembleTitle();\n\n      if (title) {\n        return title;\n      }\n    }\n\n    return undefined;\n  }\n\n  assembleLayout() {\n    return null;\n  }\n\n  assembleMarks() {\n    return assembleLayerSelectionMarks(this, this.children.flatMap(child => {\n      return child.assembleMarks();\n    }));\n  }\n\n  assembleLegends() {\n    return this.children.reduce((legends, child) => {\n      return legends.concat(child.assembleLegends());\n    }, assembleLegends(this));\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}