{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { keys } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { isConcatModel, isLayerModel, isRepeatModel } from '../model';\nimport { isRawSelectionDomain } from '../selection';\nimport { assembleSelectionScaleDomain } from '../selection/assemble';\nimport { assembleDomain } from './domain';\nexport function assembleScales(model) {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    // For concat / layer / repeat, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\nexport function assembleScalesForModel(model) {\n  return keys(model.component.scales).reduce((scales, channel) => {\n    const scaleComponent = model.component.scales[channel];\n\n    if (scaleComponent.merged) {\n      // Skipped merged scales\n      return scales;\n    }\n\n    const scale = scaleComponent.combine(); // need to separate const and non const object destruction\n\n    let domainRaw = scale.domainRaw;\n\n    const name = scale.name,\n          type = scale.type,\n          _d = scale.domains,\n          _dr = scale.domainRaw,\n          _r = scale.range,\n          otherScaleProps = __rest(scale, [\"name\", \"type\", \"domains\", \"domainRaw\", \"range\"]);\n\n    const range = assembleScaleRange(scale.range, name, channel); // As scale parsing occurs before selection parsing, a temporary signal\n    // is used for domainRaw. Here, we detect if this temporary signal\n    // is set, and replace it with the correct domainRaw signal.\n    // For more information, see isRawSelectionDomain in selection.ts.\n\n    if (domainRaw && isRawSelectionDomain(domainRaw)) {\n      domainRaw = assembleSelectionScaleDomain(model, domainRaw);\n    }\n\n    const domain = assembleDomain(model, channel);\n    scales.push(Object.assign(Object.assign(Object.assign(Object.assign({\n      name,\n      type\n    }, domain ? {\n      domain\n    } : {}), domainRaw ? {\n      domainRaw\n    } : {}), {\n      range: range\n    }), otherScaleProps));\n    return scales;\n  }, []);\n}\nexport function assembleScaleRange(scaleRange, scaleName, channel) {\n  // add signals to x/y range\n  if (channel === 'x' || channel === 'y') {\n    if (isVgRangeStep(scaleRange)) {\n      // For width/height step, use a signal created in layout assemble instead of a constant step.\n      return {\n        step: {\n          signal: scaleName + '_step'\n        }\n      };\n    }\n  }\n\n  return scaleRange;\n}","map":null,"metadata":{},"sourceType":"module"}