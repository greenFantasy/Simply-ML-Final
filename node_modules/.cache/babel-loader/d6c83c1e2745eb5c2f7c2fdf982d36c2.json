{"ast":null,"code":"import { isFieldDef } from '../../channeldef';\nimport { pathGroupingFields } from '../../encoding';\nimport { isImputeSequence } from '../../transform';\nimport { duplicate, hash } from '../../util';\nimport { DataFlowNode } from './dataflow';\nexport class ImputeNode extends DataFlowNode {\n  constructor(parent, transform) {\n    super(parent);\n    this.transform = transform;\n  }\n\n  clone() {\n    return new ImputeNode(null, duplicate(this.transform));\n  }\n\n  dependentFields() {\n    return new Set([this.transform.impute, this.transform.key, ...(this.transform.groupby || [])]);\n  }\n\n  producedFields() {\n    return new Set([this.transform.impute]);\n  }\n\n  processSequence(keyvals) {\n    const _keyvals$start = keyvals.start,\n          start = _keyvals$start === void 0 ? 0 : _keyvals$start,\n          stop = keyvals.stop,\n          step = keyvals.step;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n    return {\n      signal: \"sequence(\".concat(result, \")\")\n    };\n  }\n\n  static makeFromTransform(parent, imputeTransform) {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  static makeFromEncoding(parent, model) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const _imputedChannel$imput = imputedChannel.impute,\n            method = _imputedChannel$imput.method,\n            value = _imputedChannel$imput.value,\n            frame = _imputedChannel$imput.frame,\n            keyvals = _imputedChannel$imput.keyvals;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n      return new ImputeNode(parent, Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n        impute: imputedChannel.field,\n        key: keyChannel.field\n      }, method ? {\n        method\n      } : {}), value !== undefined ? {\n        value\n      } : {}), frame ? {\n        frame\n      } : {}), keyvals !== undefined ? {\n        keyvals\n      } : {}), groupbyFields.length ? {\n        groupby: groupbyFields\n      } : {}));\n    }\n\n    return null;\n  }\n\n  hash() {\n    return \"Impute \".concat(hash(this.transform));\n  }\n\n  assemble() {\n    const _this$transform = this.transform,\n          impute = _this$transform.impute,\n          key = _this$transform.key,\n          keyvals = _this$transform.keyvals,\n          method = _this$transform.method,\n          groupby = _this$transform.groupby,\n          value = _this$transform.value,\n          _this$transform$frame = _this$transform.frame,\n          frame = _this$transform$frame === void 0 ? [null, null] : _this$transform$frame;\n    const initialImpute = Object.assign(Object.assign(Object.assign(Object.assign({\n      type: 'impute',\n      field: impute,\n      key\n    }, keyvals ? {\n      keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals\n    } : {}), {\n      method: 'value'\n    }), groupby ? {\n      groupby\n    } : {}), {\n      value: null\n    });\n    let setImputedField;\n\n    if (method && method !== 'value') {\n      const deriveNewField = Object.assign({\n        type: 'window',\n        as: [\"imputed_\".concat(impute, \"_value\")],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false\n      }, groupby ? {\n        groupby\n      } : {});\n      const replaceOriginal = {\n        type: 'formula',\n        expr: \"datum.\".concat(impute, \" === null ? datum.imputed_\").concat(impute, \"_value : datum.\").concat(impute),\n        as: impute\n      };\n      setImputedField = [deriveNewField, replaceOriginal];\n    } else {\n      const replaceWithValue = {\n        type: 'formula',\n        expr: \"datum.\".concat(impute, \" === null ? \").concat(value, \" : datum.\").concat(impute),\n        as: impute\n      };\n      setImputedField = [replaceWithValue];\n    }\n\n    return [initialImpute, ...setImputedField];\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}