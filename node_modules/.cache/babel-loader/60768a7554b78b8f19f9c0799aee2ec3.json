{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { valueExpr, vgField } from './channeldef';\nimport { fieldExpr as timeUnitFieldExpr, normalizeTimeUnit } from './timeunit';\nexport function isSelectionPredicate(predicate) {\n  return predicate && predicate['selection'];\n}\nexport function isFieldEqualPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\nexport function isFieldLTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\nexport function isFieldLTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\nexport function isFieldGTPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\nexport function isFieldGTEPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\nexport function isFieldRangePredicate(predicate) {\n  if (predicate && predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function isFieldOneOfPredicate(predicate) {\n  return predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  ;\n}\nexport function isFieldValidPredicate(predicate) {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\nexport function isFieldPredicate(predicate) {\n  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);\n}\n\nfunction predicateValueExpr(v, timeUnit) {\n  return valueExpr(v, {\n    timeUnit,\n    time: true\n  });\n}\n\nfunction predicateValuesExpr(vals, timeUnit) {\n  return vals.map(v => predicateValueExpr(v, timeUnit));\n} // This method is used by Voyager.  Do not change its behavior without changing Voyager.\n\n\nexport function fieldFilterExpression(predicate, useInRange = true) {\n  const field = predicate.field,\n        timeUnit = predicate.timeUnit;\n  const fieldExpr = timeUnit ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n  // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n  // TODO: support utc\n  'time(' + timeUnitFieldExpr(timeUnit, field) + ')' : vgField(predicate, {\n    expr: 'datum'\n  });\n\n  if (isFieldEqualPredicate(predicate)) {\n    return fieldExpr + '===' + predicateValueExpr(predicate.equal, timeUnit);\n  } else if (isFieldLTPredicate(predicate)) {\n    const upper = predicate.lt;\n    return \"\".concat(fieldExpr, \"<\").concat(predicateValueExpr(upper, timeUnit));\n  } else if (isFieldGTPredicate(predicate)) {\n    const lower = predicate.gt;\n    return \"\".concat(fieldExpr, \">\").concat(predicateValueExpr(lower, timeUnit));\n  } else if (isFieldLTEPredicate(predicate)) {\n    const upper = predicate.lte;\n    return \"\".concat(fieldExpr, \"<=\").concat(predicateValueExpr(upper, timeUnit));\n  } else if (isFieldGTEPredicate(predicate)) {\n    const lower = predicate.gte;\n    return \"\".concat(fieldExpr, \">=\").concat(predicateValueExpr(lower, timeUnit));\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return \"indexof([\".concat(predicateValuesExpr(predicate.oneOf, timeUnit).join(','), \"], \").concat(fieldExpr, \") !== -1\");\n  } else if (isFieldValidPredicate(predicate)) {\n    return fieldValidPredicate(fieldExpr, predicate.valid);\n  } else if (isFieldRangePredicate(predicate)) {\n    const lower = predicate.range[0];\n    const upper = predicate.range[1];\n\n    if (lower !== null && upper !== null && useInRange) {\n      return 'inrange(' + fieldExpr + ', [' + predicateValueExpr(lower, timeUnit) + ', ' + predicateValueExpr(upper, timeUnit) + '])';\n    }\n\n    const exprs = [];\n\n    if (lower !== null) {\n      exprs.push(\"\".concat(fieldExpr, \" >= \").concat(predicateValueExpr(lower, timeUnit)));\n    }\n\n    if (upper !== null) {\n      exprs.push(\"\".concat(fieldExpr, \" <= \").concat(predicateValueExpr(upper, timeUnit)));\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n  /* istanbul ignore next: it should never reach here */\n\n\n  throw new Error(\"Invalid field predicate: \".concat(JSON.stringify(predicate)));\n}\nexport function fieldValidPredicate(fieldExpr, valid = true) {\n  if (valid) {\n    return \"isValid(\".concat(fieldExpr, \") && isFinite(+\").concat(fieldExpr, \")\");\n  } else {\n    return \"!isValid(\".concat(fieldExpr, \") || !isFinite(+\").concat(fieldExpr, \")\");\n  }\n}\nexport function normalizePredicate(f) {\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return Object.assign(Object.assign({}, f), {\n      timeUnit: normalizeTimeUnit(f.timeUnit)\n    });\n  }\n\n  return f;\n}","map":null,"metadata":{},"sourceType":"module"}