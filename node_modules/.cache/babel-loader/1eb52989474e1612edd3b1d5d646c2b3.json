{"ast":null,"code":"export function isLogicalOr(op) {\n  return !!op.or;\n}\nexport function isLogicalAnd(op) {\n  return !!op.and;\n}\nexport function isLogicalNot(op) {\n  return !!op.not;\n}\nexport function forEachLeaf(op, fn) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\nexport function normalizeLogicalOperand(op, normalizer) {\n  if (isLogicalNot(op)) {\n    return {\n      not: normalizeLogicalOperand(op.not, normalizer)\n    };\n  } else if (isLogicalAnd(op)) {\n    return {\n      and: op.and.map(o => normalizeLogicalOperand(o, normalizer))\n    };\n  } else if (isLogicalOr(op)) {\n    return {\n      or: op.or.map(o => normalizeLogicalOperand(o, normalizer))\n    };\n  } else {\n    return normalizer(op);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}