{"ast":null,"code":"import { isNumber } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { getBand, isFieldDef, isPositionFieldDef } from '../../channeldef';\nimport { DEFAULT_STEP, getViewConfigDiscreteStep } from '../../config';\nimport { hasDiscreteDomain, ScaleType } from '../../scale';\nimport { getFirstDefined } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { getMarkConfig } from '../common';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\nexport const rect = {\n  vgMark: 'rect',\n  encodeEntry: model => {\n    return Object.assign(Object.assign(Object.assign({}, mixins.baseEncodeEntry(model, {\n      align: 'ignore',\n      baseline: 'ignore',\n      color: 'include',\n      orient: 'ignore',\n      size: 'ignore'\n    })), rectPosition(model, 'x', 'rect')), rectPosition(model, 'y', 'rect'));\n  }\n};\nexport function rectPosition(model, channel, mark) {\n  const config = model.config,\n        encoding = model.encoding,\n        markDef = model.markDef;\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  const fieldDef = encoding[channel];\n  const fieldDef2 = encoding[channel2];\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaleName = model.scaleName(channel);\n  const orient = markDef.orient;\n  const hasSizeDef = encoding[sizeChannel] || encoding.size || markDef[sizeChannel] || markDef.size || getMarkConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  });\n  const isBarBand = channel === 'x' ? orient === 'vertical' : orient === 'horizontal'; // x, x2, and width -- we must specify two of these in all conditions\n\n  if (isFieldDef(fieldDef) && (isBinning(fieldDef.bin) || isBinned(fieldDef.bin) || fieldDef.timeUnit && !fieldDef2) && !hasSizeDef && !hasDiscreteDomain(scaleType)) {\n    const band = getBand(channel, fieldDef, undefined, markDef, config);\n    return mixins.binPosition({\n      fieldDef,\n      fieldDef2,\n      channel,\n      markDef,\n      scaleName,\n      band,\n      spacing: getFirstDefined(markDef.binSpacing, config[mark].binSpacing),\n      reverse: scale.get('reverse')\n    });\n  } else if ((isFieldDef(fieldDef) && hasDiscreteDomain(scaleType) || isBarBand) && !fieldDef2) {\n    // vertical\n    if (isFieldDef(fieldDef) && scaleType === ScaleType.BAND) {\n      const band = isPositionFieldDef(fieldDef) ? fieldDef.band : undefined;\n      return mixins.bandPosition(fieldDef, channel, model, defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config, band));\n    } // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n\n\n    return mixins.centeredPointPositionWithSize(channel, model, ref.mid(model[sizeChannel]), defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config));\n  } else {\n    return mixins.rangePosition(channel, model, {\n      defaultRef: 'zeroOrMax',\n      defaultRef2: 'zeroOrMin'\n    });\n  }\n}\n\nfunction defaultSizeRef(mark, markDef, sizeChannel, scaleName, scale, config, band) {\n  const markPropOrConfig = getFirstDefined(markDef[sizeChannel], markDef.size, // TODO: deal with sizeChannel config\n  getMarkConfig('size', markDef, config, {\n    vgChannel: sizeChannel\n  }));\n\n  if (markPropOrConfig !== undefined) {\n    return {\n      value: markPropOrConfig\n    };\n  }\n\n  if (scale) {\n    const scaleType = scale.get('type');\n\n    if (scaleType === 'point' || scaleType === 'band') {\n      if (config[mark].discreteBandSize !== undefined) {\n        return {\n          value: config[mark].discreteBandSize\n        };\n      }\n\n      if (scaleType === ScaleType.POINT) {\n        const scaleRange = scale.get('range');\n\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n          return {\n            value: scaleRange.step - 2\n          };\n        }\n\n        return {\n          value: DEFAULT_STEP - 2\n        };\n      } else {\n        // BAND\n        return ref.bandRef(scaleName, band);\n      }\n    } else {\n      // continuous scale\n      return {\n        value: config[mark].continuousBandSize\n      };\n    }\n  } // No Scale\n\n\n  const step = getViewConfigDiscreteStep(config.view, sizeChannel);\n  const value = getFirstDefined( // No scale is like discrete bar (with one item)\n  config[mark].discreteBandSize, step - 2);\n  return {\n    value\n  };\n}","map":null,"metadata":{},"sourceType":"module"}