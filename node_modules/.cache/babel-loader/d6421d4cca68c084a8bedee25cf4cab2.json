{"ast":null,"code":"import { array, isArray } from 'vega-util';\nimport { isBinning } from '../bin';\nimport { isScaleFieldDef, isTimeFormatFieldDef, vgField } from '../channeldef';\nimport { fieldValidPredicate } from '../predicate';\nimport { ScaleType } from '../scale';\nimport { formatExpression } from '../timeunit';\nimport { QUANTITATIVE } from '../type';\nimport { getFirstDefined, stringify } from '../util';\nexport function applyMarkConfig(e, model, propsList) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n\n    if (value !== undefined) {\n      e[property] = {\n        value: value\n      };\n    }\n  }\n\n  return e;\n}\nexport function getStyles(mark) {\n  return [].concat(mark.type, mark.style || []);\n}\nexport function getMarkPropOrConfig(channel, mark, config) {\n  return getFirstDefined(mark[channel], getMarkConfig(channel, mark, config));\n}\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\n\nexport function getMarkConfig(channel, mark, config, {\n  vgChannel\n} = {} // Note: Ham: I use `any` here as it's too hard to make TS knows that MarkConfig[vgChannel] would have the same type as MarkConfig[P]\n) {\n  return getFirstDefined( // style config has highest precedence\n  vgChannel ? getStyleConfig(channel, mark, config.style) : undefined, getStyleConfig(channel, mark, config.style), // then mark-specific config\n  vgChannel ? config[mark.type][vgChannel] : undefined, config[mark.type][channel], // If there is vgChannel, skip vl channel.\n  // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.\n  vgChannel ? config.mark[vgChannel] : config.mark[channel]);\n}\nexport function getStyleConfig(prop, mark, styleConfigIndex) {\n  const styles = getStyles(mark);\n  let value;\n\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style]; // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n\n    const p = prop;\n\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n\n  return value;\n}\nexport function formatSignalRef(fieldDef, specifiedFormat, expr, config) {\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(vgField(fieldDef, {\n        expr\n      }), fieldDef.timeUnit, specifiedFormat, config.text.shortTimeLabels, config.timeFormat, isUTCScale, true)\n    };\n  } else {\n    const format = numberFormat(fieldDef, specifiedFormat, config);\n\n    if (isBinning(fieldDef.bin)) {\n      const startField = vgField(fieldDef, {\n        expr\n      });\n      const endField = vgField(fieldDef, {\n        expr,\n        binSuffix: 'end'\n      });\n      return {\n        signal: binFormatExpression(startField, endField, format, config)\n      };\n    } else if (fieldDef.type === 'quantitative' || format) {\n      return {\n        signal: \"\".concat(formatExpr(vgField(fieldDef, {\n          expr,\n          binSuffix: 'range'\n        }), format))\n      };\n    } else {\n      return {\n        signal: \"''+\".concat(vgField(fieldDef, {\n          expr\n        }))\n      };\n    }\n  }\n}\n/**\n * Returns number format for a fieldDef\n */\n\nexport function numberFormat(fieldDef, specifiedFormat, config) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  if (specifiedFormat) {\n    return specifiedFormat;\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    // we only apply the default if the field is quantitative\n    return config.numberFormat;\n  }\n\n  return undefined;\n}\n\nfunction formatExpr(field, format) {\n  return \"format(\".concat(field, \", \\\"\").concat(format || '', \"\\\")\");\n}\n\nexport function numberFormatExpr(field, specifiedFormat, config) {\n  return formatExpr(field, specifiedFormat || config.numberFormat);\n}\nexport function binFormatExpression(startField, endField, format, config) {\n  return \"\".concat(fieldValidPredicate(startField, false), \" ? \\\"null\\\" : \").concat(numberFormatExpr(startField, format, config), \" + \\\" - \\\" + \").concat(numberFormatExpr(endField, format, config));\n}\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\n\nexport function timeFormatExpression(field, timeUnit, format, shortTimeLabels, rawTimeFormat, // should be provided only for actual text and headers, not axis/legend labels\nisUTCScale, alwaysReturn = false) {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format || rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    if (format || alwaysReturn) {\n      return \"\".concat(isUTCScale ? 'utc' : 'time', \"Format(\").concat(field, \", '\").concat(format, \"')\");\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels, isUTCScale);\n  }\n}\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\n\nexport function sortParams(orderDef, fieldRefOption) {\n  return array(orderDef).reduce((s, orderChannelDef) => {\n    s.field.push(vgField(orderChannelDef, fieldRefOption));\n    s.order.push(orderChannelDef.sort || 'ascending');\n    return s;\n  }, {\n    field: [],\n    order: []\n  });\n}\nexport function mergeTitleFieldDefs(f1, f2) {\n  const merged = [...f1];\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (stringify(fieldDef1) === stringify(fdToMerge)) {\n        return;\n      }\n    }\n\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\nexport function mergeTitle(title1, title2) {\n  if (title1 === title2 || !title2) {\n    // if titles are the same or title2 is falsy\n    return title1;\n  } else if (!title1) {\n    // if title1 is falsy\n    return title2;\n  } else {\n    // join title with comma if they are different\n    return title1 + ', ' + title2;\n  }\n}\nexport function mergeTitleComponent(v1, v2) {\n  if (isArray(v1.value) && isArray(v2.value)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1.value, v2.value)\n    };\n  } else if (!isArray(v1.value) && !isArray(v2.value)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitle(v1.value, v2.value)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n\n\n  throw new Error('It should never reach here');\n}","map":null,"metadata":{},"sourceType":"module"}