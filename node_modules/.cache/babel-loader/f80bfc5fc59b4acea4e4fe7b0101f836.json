{"ast":null,"code":"import { isFunction, isString, stringValue } from 'vega-util';\nimport { isCountingAggregateOp } from '../../aggregate';\nimport { isBinned, isBinning } from '../../bin';\nimport { getMainRangeChannel, X, X2, Y, Y2 } from '../../channel';\nimport { binRequiresRange, format, getBand, getFieldDef, hasConditionalFieldDef, isFieldDef, isPositionFieldDef, isTypedFieldDef, isValueDef, title, vgField } from '../../channeldef';\nimport { forEach } from '../../encoding';\nimport * as log from '../../log';\nimport { isPathMark } from '../../mark';\nimport { fieldValidPredicate } from '../../predicate';\nimport { hasDiscreteDomain, isContinuousToContinuous, ScaleType } from '../../scale';\nimport { QUANTITATIVE, TEMPORAL } from '../../type';\nimport { contains, getFirstDefined } from '../../util';\nimport { binFormatExpression, formatSignalRef, getMarkConfig } from '../common';\n\nfunction midPointWithPositionInvalidTest(params) {\n  const channel = params.channel,\n        channelDef = params.channelDef,\n        markDef = params.markDef,\n        scale = params.scale;\n  const ref = midPoint(params); // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n\n  if ( // Only this for field def without counting aggregate (as count wouldn't be null)\n  isFieldDef(channelDef) && !isCountingAggregateOp(channelDef.aggregate) && // and only for continuous scale without zero (otherwise, null / invalid will be interpreted as zero, which doesn't cause layout problem)\n  scale && isContinuousToContinuous(scale.get('type')) && scale.get('zero') === false) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel,\n      markDef,\n      ref\n    });\n  }\n\n  return ref;\n}\n\nfunction wrapPositionInvalidTest({\n  fieldDef,\n  channel,\n  markDef,\n  ref\n}) {\n  if (!isPathMark(markDef.type)) {\n    // Only do this for non-path mark (as path marks will already use \"defined\" to skip points)\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n\n  return ref;\n}\n\nexport function fieldInvalidTestValueRef(fieldDef, channel) {\n  const test = fieldInvalidPredicate(fieldDef, true);\n  const mainChannel = getMainRangeChannel(channel);\n  const zeroValueRef = mainChannel === 'x' ? {\n    value: 0\n  } : {\n    field: {\n      group: 'height'\n    }\n  };\n  return Object.assign({\n    test\n  }, zeroValueRef);\n}\nexport function fieldInvalidPredicate(field, invalid = true) {\n  return fieldValidPredicate(isString(field) ? field : vgField(field, {\n    expr: 'datum'\n  }), !invalid);\n} // TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\n\nexport function position(params) {\n  const channel = params.channel,\n        channelDef = params.channelDef,\n        scaleName = params.scaleName,\n        stack = params.stack,\n        offset = params.offset;\n\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    if (isPositionFieldDef(channelDef) && channelDef.band !== undefined) {\n      return interpolatedPositionSignal({\n        scaleName,\n        fieldDef: channelDef,\n        startSuffix: 'start',\n        band: channelDef.band,\n        offset: 0\n      });\n    } // x or y use stack_end so that stacked line's point mark use stack_end too.\n\n\n    return fieldRef(channelDef, scaleName, {\n      suffix: 'end'\n    }, {\n      offset\n    });\n  }\n\n  return midPointWithPositionInvalidTest(params);\n}\n/**\n * @return Vega ValueRef for normal x2- or y2-position without projection\n */\n\nexport function position2({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}) {\n  if (isFieldDef(channelDef) && stack && // If fieldChannel is X and channel is X2 (or Y and Y2)\n  channel.charAt(0) === stack.fieldChannel.charAt(0)) {\n    return fieldRef(channelDef, scaleName, {\n      suffix: 'start'\n    }, {\n      offset\n    });\n  }\n\n  return midPointWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    markDef,\n    config,\n    offset,\n    defaultRef\n  });\n}\nexport function getOffset(channel, markDef) {\n  const offsetChannel = channel + 'Offset'; // Need to cast as the type can't be inferred automatically\n  // TODO: in the future read from encoding channel too\n\n  const markDefOffsetValue = markDef[offsetChannel];\n\n  if (markDefOffsetValue) {\n    return markDefOffsetValue;\n  }\n\n  return undefined;\n}\n/**\n * Value Ref for binned fields\n */\n\nexport function bin({\n  channel,\n  fieldDef,\n  scaleName,\n  markDef,\n  band,\n  offset\n}) {\n  const ref = interpolatedPositionSignal({\n    scaleName,\n    fieldDef,\n    band,\n    offset\n  });\n  return wrapPositionInvalidTest({\n    fieldDef,\n    channel,\n    markDef,\n    ref\n  });\n}\nexport function fieldRef(fieldDef, scaleName, opt, mixins) {\n  const ref = Object.assign(Object.assign({}, scaleName ? {\n    scale: scaleName\n  } : {}), {\n    field: vgField(fieldDef, opt)\n  });\n\n  if (mixins) {\n    const offset = mixins.offset,\n          band = mixins.band;\n    return Object.assign(Object.assign(Object.assign({}, ref), offset ? {\n      offset\n    } : {}), band ? {\n      band\n    } : {});\n  }\n\n  return ref;\n}\nexport function bandRef(scaleName, band = true) {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\n\nfunction interpolatedPositionSignal({\n  scaleName,\n  fieldDef,\n  fieldDef2,\n  offset,\n  startSuffix,\n  band = 0.5\n}) {\n  const expr = 0 < band && band < 1 ? 'datum' : undefined;\n  const start = vgField(fieldDef, {\n    expr,\n    suffix: startSuffix\n  });\n  const end = fieldDef2 !== undefined ? vgField(fieldDef2, {\n    expr\n  }) : vgField(fieldDef, {\n    suffix: 'end',\n    expr\n  });\n\n  if (band === 0) {\n    return Object.assign({\n      scale: scaleName,\n      field: start\n    }, offset ? {\n      offset\n    } : {});\n  } else if (band === 1) {\n    return Object.assign({\n      scale: scaleName,\n      field: end\n    }, offset ? {\n      offset\n    } : {});\n  } else {\n    const datum = \"\".concat(band, \" * \").concat(start, \" + \").concat(1 - band, \" * \").concat(end);\n    return Object.assign({\n      signal: \"scale(\\\"\".concat(scaleName, \"\\\", \").concat(datum, \")\")\n    }, offset ? {\n      offset\n    } : {});\n  }\n}\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\n\n\nexport function midPoint({\n  channel,\n  channelDef,\n  channel2Def,\n  markDef,\n  config,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}) {\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldDef(channelDef)) {\n      if (isTypedFieldDef(channelDef)) {\n        const band = getBand(channel, channelDef, channel2Def, markDef, config, {\n          isMidPoint: true\n        });\n\n        if (isBinning(channelDef.bin) || band && channelDef.timeUnit) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (contains([X, Y], channel) && contains([QUANTITATIVE, TEMPORAL], channelDef.type)) {\n            if (stack && stack.impute) {\n              // For stack, we computed bin_mid so we can impute.\n              return fieldRef(channelDef, scaleName, {\n                binSuffix: 'mid'\n              }, {\n                offset\n              });\n            } // For non-stack, we can just calculate bin mid on the fly using signal.\n\n\n            return interpolatedPositionSignal({\n              scaleName,\n              fieldDef: channelDef,\n              band,\n              offset\n            });\n          }\n\n          return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {\n            binSuffix: 'range'\n          } : {}, {\n            offset\n          });\n        } else if (isBinned(channelDef.bin)) {\n          if (isFieldDef(channel2Def)) {\n            return interpolatedPositionSignal({\n              scaleName,\n              fieldDef: channelDef,\n              fieldDef2: channel2Def,\n              band,\n              offset\n            });\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      if (scale) {\n        const scaleType = scale.get('type');\n\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            const band = getFirstDefined(isPositionFieldDef(channelDef) ? channelDef.band : undefined, 0.5);\n            return fieldRef(channelDef, scaleName, {\n              binSuffix: 'range'\n            }, {\n              band,\n              offset\n            });\n          }\n\n          return fieldRef(channelDef, scaleName, {\n            binSuffix: 'range'\n          }, {\n            offset\n          });\n        }\n      }\n\n      return fieldRef(channelDef, scaleName, {}, {\n        offset\n      }); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n      const offsetMixins = offset ? {\n        offset\n      } : {};\n      return Object.assign(Object.assign({}, vgValueRef(channel, value)), offsetMixins);\n    } // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n\n  }\n\n  return isFunction(defaultRef) ? defaultRef() : defaultRef;\n}\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\n\nexport function vgValueRef(channel, value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {\n      field: {\n        group: 'width'\n      }\n    };\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {\n      field: {\n        group: 'height'\n      }\n    };\n  }\n\n  return {\n    value\n  };\n}\nexport function tooltipForEncoding(encoding, config, {\n  reactiveGeom\n} = {}) {\n  const keyValues = [];\n  const usedKey = {};\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tooltipTuples = [];\n\n  function add(fDef, channel) {\n    const mainChannel = getMainRangeChannel(channel);\n    const fieldDef = isTypedFieldDef(fDef) ? fDef : Object.assign(Object.assign({}, fDef), {\n      type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n\n    });\n    const key = title(fieldDef, config, {\n      allowDisabling: false\n    });\n    let value = text(fieldDef, config, expr).signal;\n\n    if (channel === 'x' || channel === 'y') {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {\n          expr\n        });\n        const endField = vgField(fieldDef2, {\n          expr\n        });\n        value = binFormatExpression(startField, endField, format(fieldDef), config);\n        toSkip[channel2] = true;\n      }\n    }\n\n    tooltipTuples.push({\n      channel,\n      key,\n      value\n    });\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  for (const _ref of tooltipTuples) {\n    const channel = _ref.channel;\n    const key = _ref.key;\n    const value = _ref.value;\n\n    if (!toSkip[channel] && !usedKey[key]) {\n      keyValues.push(\"\".concat(stringValue(key), \": \").concat(value));\n      usedKey[key] = true;\n    }\n  }\n\n  return keyValues.length ? {\n    signal: \"{\".concat(keyValues.join(', '), \"}\")\n  } : undefined;\n}\nexport function text(channelDef, config, expr = 'datum') {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return {\n        value: channelDef.value\n      };\n    }\n\n    if (isTypedFieldDef(channelDef)) {\n      return formatSignalRef(channelDef, format(channelDef), expr, config);\n    }\n  }\n\n  return undefined;\n}\nexport function mid(sizeRef) {\n  return Object.assign(Object.assign({}, sizeRef), {\n    mult: 0.5\n  });\n}\nexport function positionDefault({\n  markDef,\n  config,\n  defaultRef,\n  channel,\n  scaleName,\n  scale,\n  mark,\n  checkBarAreaWithoutZero: checkBarAreaWithZero\n}) {\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n    const definedValueOrConfig = getFirstDefined(markDef[channel], getMarkConfig(channel, markDef, config));\n\n    if (definedValueOrConfig !== undefined) {\n      return vgValueRef(channel, definedValueOrConfig);\n    }\n\n    if (isString(defaultRef)) {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              scaleType\n            }));\n          }\n        } else {\n          if (scale.domainDefinitelyIncludesZero()) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {\n              zeroFalse: scale.explicit.zero === false\n            }));\n          }\n        }\n      }\n\n      if (defaultRef === 'zeroOrMin') {\n        return mainChannel === 'x' ? {\n          value: 0\n        } : {\n          field: {\n            group: 'height'\n          }\n        };\n      } else {\n        // zeroOrMax\n        return mainChannel === 'x' ? {\n          field: {\n            group: 'width'\n          }\n        } : {\n          value: 0\n        };\n      }\n    }\n\n    return defaultRef;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}