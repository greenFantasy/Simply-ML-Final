{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isNumber, isObject } from 'vega-util';\nimport { extractTransformsFromEncoding } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined, keys } from '../util';\nimport { CompositeMarkNormalizer } from './base';\nimport { compositeMarkContinuousAxis, compositeMarkOrient, filterTooltipWithAggregatedField, getCompositeMarkTooltip, getTitle, makeCompositeAggregatePartFactory, partLayerMixins } from './common';\nexport const BOXPLOT = 'boxplot';\nconst BOXPLOT_PART_INDEX = {\n  box: 1,\n  median: 1,\n  outliers: 1,\n  rule: 1,\n  ticks: 1\n};\nexport const BOXPLOT_PARTS = keys(BOXPLOT_PART_INDEX);\nexport const boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);\nexport function getBoxPlotType(extent) {\n  if (isNumber(extent)) {\n    return 'tukey';\n  } // Ham: If we ever want to, we could add another extent syntax `{kIQR: number}` for the original [Q1-k*IQR, Q3+k*IQR] whisker and call this boxPlotType = `kIQR`.  However, I'm not exposing this for now.\n\n\n  return extent;\n}\nexport function normalizeBoxPlot(spec, {\n  config\n}) {\n  // TODO: use selection\n  const mark = spec.mark,\n        _encoding = spec.encoding,\n        selection = spec.selection,\n        _p = spec.projection,\n        outerSpec = __rest(spec, [\"mark\", \"encoding\", \"selection\", \"projection\"]);\n\n  const markDef = isMarkDef(mark) ? mark : {\n    type: mark\n  }; // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n\n  if (selection) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  const extent = markDef.extent || config.boxplot.extent;\n  const sizeValue = getFirstDefined(markDef.size, config.boxplot.size);\n  const boxPlotType = getBoxPlotType(extent);\n\n  const _boxParams = boxParams(spec, extent, config),\n        transform = _boxParams.transform,\n        continuousAxisChannelDef = _boxParams.continuousAxisChannelDef,\n        continuousAxis = _boxParams.continuousAxis,\n        groupby = _boxParams.groupby,\n        aggregate = _boxParams.aggregate,\n        encodingWithoutContinuousAxis = _boxParams.encodingWithoutContinuousAxis,\n        ticksOrient = _boxParams.ticksOrient,\n        boxOrient = _boxParams.boxOrient,\n        customTooltipWithoutAggregatedField = _boxParams.customTooltipWithoutAggregatedField;\n\n  const color = encodingWithoutContinuousAxis.color,\n        size = encodingWithoutContinuousAxis.size,\n        encodingWithoutSizeColorAndContinuousAxis = __rest(encodingWithoutContinuousAxis, [\"color\", \"size\"]);\n\n  const makeBoxPlotPart = sharedEncoding => {\n    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);\n  };\n\n  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  const makeBoxPlotMidTick = makeBoxPlotPart(Object.assign(Object.assign({}, encodingWithoutSizeColorAndContinuousAxis), size ? {\n    size\n  } : {}));\n  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([{\n    fieldPrefix: boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_',\n    titlePrefix: 'Max'\n  }, {\n    fieldPrefix: 'upper_box_',\n    titlePrefix: 'Q3'\n  }, {\n    fieldPrefix: 'mid_box_',\n    titlePrefix: 'Median'\n  }, {\n    fieldPrefix: 'lower_box_',\n    titlePrefix: 'Q1'\n  }, {\n    fieldPrefix: boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_',\n    titlePrefix: 'Min'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis); // ## Whisker Layers\n\n  const endTick = {\n    type: 'tick',\n    color: 'black',\n    opacity: 1,\n    orient: ticksOrient,\n    invalid: null\n  };\n  const whiskerTooltipEncoding = boxPlotType === 'min-max' ? fiveSummaryTooltipEncoding // for min-max, show five-summary tooltip for whisker\n  : // for tukey / k-IQR, just show upper/lower-whisker\n  getCompositeMarkTooltip([{\n    fieldPrefix: 'upper_whisker_',\n    titlePrefix: 'Upper Whisker'\n  }, {\n    fieldPrefix: 'lower_whisker_',\n    titlePrefix: 'Lower Whisker'\n  }], continuousAxisChannelDef, encodingWithoutContinuousAxis);\n  const whiskerLayers = [...makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null\n    },\n    positionPrefix: 'lower_whisker',\n    endPositionPrefix: 'lower_box',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'rule',\n    mark: {\n      type: 'rule',\n      invalid: null\n    },\n    positionPrefix: 'upper_box',\n    endPositionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'lower_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  }), ...makeBoxPlotExtent({\n    partName: 'ticks',\n    mark: endTick,\n    positionPrefix: 'upper_whisker',\n    extraEncoding: whiskerTooltipEncoding\n  })]; // ## Box Layers\n  // TODO: support hiding certain mark parts\n\n  const boxLayers = [...(boxPlotType !== 'tukey' ? whiskerLayers : []), ...makeBoxPlotBox({\n    partName: 'box',\n    mark: Object.assign(Object.assign({\n      type: 'bar'\n    }, sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: boxOrient,\n      invalid: null\n    }),\n    positionPrefix: 'lower_box',\n    endPositionPrefix: 'upper_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  }), ...makeBoxPlotMidTick({\n    partName: 'median',\n    mark: Object.assign(Object.assign(Object.assign({\n      type: 'tick',\n      invalid: null\n    }, isObject(config.boxplot.median) && config.boxplot.median.color ? {\n      color: config.boxplot.median.color\n    } : {}), sizeValue ? {\n      size: sizeValue\n    } : {}), {\n      orient: ticksOrient\n    }),\n    positionPrefix: 'mid_box',\n    extraEncoding: fiveSummaryTooltipEncoding\n  })]; // ## Filtered Layers\n\n  let filteredLayersMixins;\n\n  if (boxPlotType !== 'min-max') {\n    const lowerBoxExpr = \"datum[\\\"lower_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n    const upperBoxExpr = \"datum[\\\"upper_box_\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n    const iqrExpr = \"(\".concat(upperBoxExpr, \" - \").concat(lowerBoxExpr, \")\");\n    const lowerWhiskerExpr = \"\".concat(lowerBoxExpr, \" - \").concat(extent, \" * \").concat(iqrExpr);\n    const upperWhiskerExpr = \"\".concat(upperBoxExpr, \" + \").concat(extent, \" * \").concat(iqrExpr);\n    const fieldExpr = \"datum[\\\"\".concat(continuousAxisChannelDef.field, \"\\\"]\");\n    const joinaggregateTransform = {\n      joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),\n      groupby\n    };\n    let filteredWhiskerSpec = undefined;\n\n    if (boxPlotType === 'tukey') {\n      filteredWhiskerSpec = {\n        transform: [{\n          filter: \"(\".concat(lowerWhiskerExpr, \" <= \").concat(fieldExpr, \") && (\").concat(fieldExpr, \" <= \").concat(upperWhiskerExpr, \")\")\n        }, {\n          aggregate: [{\n            op: 'min',\n            field: continuousAxisChannelDef.field,\n            as: 'lower_whisker_' + continuousAxisChannelDef.field\n          }, {\n            op: 'max',\n            field: continuousAxisChannelDef.field,\n            as: 'upper_whisker_' + continuousAxisChannelDef.field\n          }, // preserve lower_box / upper_box\n          {\n            op: 'min',\n            field: 'lower_box_' + continuousAxisChannelDef.field,\n            as: 'lower_box_' + continuousAxisChannelDef.field\n          }, {\n            op: 'max',\n            field: 'upper_box_' + continuousAxisChannelDef.field,\n            as: 'upper_box_' + continuousAxisChannelDef.field\n          }, ...aggregate],\n          groupby\n        }],\n        layer: whiskerLayers\n      };\n    }\n\n    const tooltip = encodingWithoutSizeColorAndContinuousAxis.tooltip,\n          encodingWithoutSizeColorContinuousAxisAndTooltip = __rest(encodingWithoutSizeColorAndContinuousAxis, [\"tooltip\"]);\n\n    const scale = continuousAxisChannelDef.scale,\n          axis = continuousAxisChannelDef.axis;\n    const title = getTitle(continuousAxisChannelDef);\n    const outlierLayersMixins = partLayerMixins(markDef, 'outliers', config.boxplot, {\n      transform: [{\n        filter: \"(\".concat(fieldExpr, \" < \").concat(lowerWhiskerExpr, \") || (\").concat(fieldExpr, \" > \").concat(upperWhiskerExpr, \")\")\n      }],\n      mark: 'point',\n      encoding: Object.assign(Object.assign({\n        [continuousAxis]: Object.assign(Object.assign(Object.assign({\n          field: continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type\n        }, title !== undefined ? {\n          title\n        } : {}), scale !== undefined ? {\n          scale\n        } : {}), axis !== undefined ? {\n          axis\n        } : {})\n      }, encodingWithoutSizeColorContinuousAxisAndTooltip), customTooltipWithoutAggregatedField ? {\n        tooltip: customTooltipWithoutAggregatedField\n      } : {})\n    })[0];\n\n    if (outlierLayersMixins && filteredWhiskerSpec) {\n      filteredLayersMixins = {\n        transform: [joinaggregateTransform],\n        layer: [outlierLayersMixins, filteredWhiskerSpec]\n      };\n    } else if (outlierLayersMixins) {\n      filteredLayersMixins = outlierLayersMixins;\n      filteredLayersMixins.transform.unshift(joinaggregateTransform);\n    } else if (filteredWhiskerSpec) {\n      filteredLayersMixins = filteredWhiskerSpec;\n      filteredLayersMixins.transform.unshift(joinaggregateTransform);\n    }\n  }\n\n  if (filteredLayersMixins) {\n    // tukey box plot with outliers included\n    return Object.assign(Object.assign({}, outerSpec), {\n      layer: [filteredLayersMixins, {\n        // boxplot\n        transform,\n        layer: boxLayers\n      }]\n    });\n  }\n\n  return Object.assign(Object.assign({}, outerSpec), {\n    transform: (outerSpec.transform || []).concat(transform),\n    layer: boxLayers\n  });\n}\n\nfunction boxParamsQuartiles(continousAxisField) {\n  return [{\n    op: 'q1',\n    field: continousAxisField,\n    as: 'lower_box_' + continousAxisField\n  }, {\n    op: 'q3',\n    field: continousAxisField,\n    as: 'upper_box_' + continousAxisField\n  }];\n}\n\nfunction boxParams(spec, extent, config) {\n  const orient = compositeMarkOrient(spec, BOXPLOT);\n\n  const _compositeMarkContinu = compositeMarkContinuousAxis(spec, orient, BOXPLOT),\n        continuousAxisChannelDef = _compositeMarkContinu.continuousAxisChannelDef,\n        continuousAxis = _compositeMarkContinu.continuousAxis;\n\n  const continuousFieldName = continuousAxisChannelDef.field;\n  const boxPlotType = getBoxPlotType(extent);\n  const boxplotSpecificAggregate = [...boxParamsQuartiles(continuousFieldName), {\n    op: 'median',\n    field: continuousFieldName,\n    as: 'mid_box_' + continuousFieldName\n  }, {\n    op: 'min',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'lower_whisker_' : 'min_') + continuousFieldName\n  }, {\n    op: 'max',\n    field: continuousFieldName,\n    as: (boxPlotType === 'min-max' ? 'upper_whisker_' : 'max_') + continuousFieldName\n  }];\n  const postAggregateCalculates = boxPlotType === 'min-max' || boxPlotType === 'tukey' ? [] : [// This is for the  original k-IQR, which we do not expose\n  {\n    calculate: \"datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"lower_box_\").concat(continuousFieldName, \"\\\"]\"),\n    as: 'iqr_' + continuousFieldName\n  }, {\n    calculate: \"min(datum[\\\"upper_box_\".concat(continuousFieldName, \"\\\"] + datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"max_\").concat(continuousFieldName, \"\\\"])\"),\n    as: 'upper_whisker_' + continuousFieldName\n  }, {\n    calculate: \"max(datum[\\\"lower_box_\".concat(continuousFieldName, \"\\\"] - datum[\\\"iqr_\").concat(continuousFieldName, \"\\\"] * \").concat(extent, \", datum[\\\"min_\").concat(continuousFieldName, \"\\\"])\"),\n    as: 'lower_whisker_' + continuousFieldName\n  }];\n\n  const _a = spec.encoding,\n        _b = continuousAxis,\n        oldContinuousAxisChannelDef = _a[_b],\n        oldEncodingWithoutContinuousAxis = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n  const _filterTooltipWithAgg = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis),\n        customTooltipWithoutAggregatedField = _filterTooltipWithAgg.customTooltipWithoutAggregatedField,\n        filteredEncoding = _filterTooltipWithAgg.filteredEncoding;\n\n  const _extractTransformsFro = extractTransformsFromEncoding(filteredEncoding, config),\n        bins = _extractTransformsFro.bins,\n        timeUnits = _extractTransformsFro.timeUnits,\n        aggregate = _extractTransformsFro.aggregate,\n        groupby = _extractTransformsFro.groupby,\n        encodingWithoutContinuousAxis = _extractTransformsFro.encoding;\n\n  const ticksOrient = orient === 'vertical' ? 'horizontal' : 'vertical';\n  const boxOrient = orient;\n  const transform = [...bins, ...timeUnits, {\n    aggregate: [...aggregate, ...boxplotSpecificAggregate],\n    groupby\n  }, ...postAggregateCalculates];\n  return {\n    transform,\n    groupby,\n    aggregate,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    boxOrient,\n    customTooltipWithoutAggregatedField\n  };\n}","map":null,"metadata":{},"sourceType":"module"}