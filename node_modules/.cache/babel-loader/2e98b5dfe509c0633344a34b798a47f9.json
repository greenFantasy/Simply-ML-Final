{"ast":null,"code":"import { isArgmaxDef, isArgminDef } from '../../aggregate';\nimport { getPositionChannelFromLatLong, getSecondaryRangeChannel, isGeoPositionChannel, isScaleChannel } from '../../channel';\nimport { binRequiresRange, hasBand, isTypedFieldDef, vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { duplicate, hash, keys, replacePathInField, setEqual } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\n\nfunction addDimension(dims, channel, fieldDef, model) {\n  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n\n  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.markDef, model.config)) {\n    dims.add(vgField(fieldDef, {}));\n    dims.add(vgField(fieldDef, {\n      suffix: 'end'\n    }));\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims.add(vgField(fieldDef, {\n        binSuffix: 'range'\n      }));\n    }\n  } else if (isGeoPositionChannel(channel)) {\n    const posChannel = getPositionChannelFromLatLong(channel);\n    dims.add(model.getName(posChannel));\n  } else {\n    dims.add(vgField(fieldDef));\n  }\n\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures, childMeasures) {\n  for (const field of keys(childMeasures)) {\n    // when we merge a measure, we either have to add an aggregation operator or even a new field\n    const ops = childMeasures[field];\n\n    for (const op of keys(ops)) {\n      if (field in parentMeasures) {\n        // add operator to existing measure field\n        parentMeasures[field][op] = new Set([...(parentMeasures[field][op] || []), ...ops[op]]);\n      } else {\n        parentMeasures[field] = {\n          [op]: ops[op]\n        };\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(parent, dimensions, measures) {\n    super(parent);\n    this.dimensions = dimensions;\n    this.measures = measures;\n  }\n\n  clone() {\n    return new AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));\n  }\n\n  get groupBy() {\n    return this.dimensions;\n  }\n\n  static makeFromEncoding(parent, model) {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n    const meas = {};\n    const dims = new Set();\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      const aggregate = fieldDef.aggregate,\n            field = fieldDef.field;\n\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = new Set([vgField(fieldDef, {\n            forAs: true\n          })]);\n        } else {\n          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {\n            const op = isArgminDef(aggregate) ? 'argmin' : 'argmax';\n            const argField = aggregate[op];\n            meas[argField] = meas[argField] || {};\n            meas[argField][op] = new Set([vgField({\n              op,\n              field: argField\n            }, {\n              forAs: true\n            })]);\n          } else {\n            meas[field] = meas[field] || {};\n            meas[field][aggregate] = new Set([vgField(fieldDef, {\n              forAs: true\n            })]);\n          } // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n\n\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field] = meas[field] || {};\n            meas[field]['min'] = new Set([vgField({\n              field,\n              aggregate: 'min'\n            }, {\n              forAs: true\n            })]);\n            meas[field]['max'] = new Set([vgField({\n              field,\n              aggregate: 'max'\n            }, {\n              forAs: true\n            })]);\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef, model);\n      }\n    });\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  static makeFromTransform(parent, t) {\n    const dims = new Set();\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const op = s.op,\n            field = s.field,\n            as = s.as;\n\n      if (op) {\n        if (op === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = new Set([as ? as : vgField(s, {\n            forAs: true\n          })]);\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][op] = new Set([as ? as : vgField(s, {\n            forAs: true\n          })]);\n        }\n      }\n    }\n\n    for (const s of t.groupby || []) {\n      dims.add(s);\n    }\n\n    if (dims.size + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  merge(other) {\n    if (setEqual(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      return true;\n    } else {\n      log.debug('different dimensions, cannot merge');\n      return false;\n    }\n  }\n\n  addDimensions(fields) {\n    fields.forEach(this.dimensions.add, this.dimensions);\n  }\n\n  dependentFields() {\n    return new Set([...this.dimensions, ...keys(this.measures)]);\n  }\n\n  producedFields() {\n    const out = new Set();\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        const m = this.measures[field][op];\n\n        if (m.size === 0) {\n          out.add(\"\".concat(op, \"_\").concat(field));\n        } else {\n          m.forEach(out.add, out);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  hash() {\n    return \"Aggregate \".concat(hash({\n      dimensions: this.dimensions,\n      measures: this.measures\n    }));\n  }\n\n  assemble() {\n    const ops = [];\n    const fields = [];\n    const as = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        for (const alias of this.measures[field][op]) {\n          as.push(alias);\n          ops.push(op);\n          fields.push(field === '*' ? null : replacePathInField(field));\n        }\n      }\n    }\n\n    const result = {\n      type: 'aggregate',\n      groupby: [...this.dimensions],\n      ops,\n      fields,\n      as\n    };\n    return result;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}