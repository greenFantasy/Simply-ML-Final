{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { COLOR, OPACITY } from '../../channel';\nimport { hasConditionalValueDef, isTimeFormatFieldDef, isValueDef } from '../../channeldef';\nimport { FILL_STROKE_CONFIG } from '../../mark';\nimport { ScaleType } from '../../scale';\nimport { getFirstDefined, keys } from '../../util';\nimport { applyMarkConfig, timeFormatExpression } from '../common';\nimport * as mixins from '../mark/mixins';\nimport { defaultType } from './properties';\n\nfunction type(legendCmp, model, channel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  return getFirstDefined(legendCmp.get('type'), defaultType({\n    channel,\n    scaleType,\n    alwaysReturn: true\n  }));\n}\n\nexport function symbols(fieldDef, symbolsSpec, model, channel, legendCmp) {\n  if (type(legendCmp, model, channel) !== 'symbol') {\n    return undefined;\n  }\n\n  let out = Object.assign(Object.assign({}, applyMarkConfig({}, model, FILL_STROKE_CONFIG)), mixins.color(model)); // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const markDef = model.markDef,\n        encoding = model.encoding,\n        config = model.config;\n  const filled = markDef.filled;\n  const opacity = getMaxValue(encoding.opacity) || markDef.opacity;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || filled && channel === COLOR) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (legendCmp.get('symbolFillColor')) {\n          delete out.fill;\n        } else {\n          out.fill = {\n            value: config.legend.symbolBaseFillColor || 'black'\n          };\n          out.fillOpacity = {\n            value: opacity || 1\n          };\n        }\n      } else if (isArray(out.fill)) {\n        const fill = getFirstConditionValue(encoding.fill || encoding.color) || markDef.fill || filled && markDef.color;\n\n        if (fill) {\n          out.fill = {\n            value: fill\n          };\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || !filled && channel === COLOR) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : undefined);\n\n        if (stroke) {\n          out.stroke = {\n            value: stroke\n          };\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    if (opacity) {\n      // only apply opacity if it is neither zero or undefined\n      out.opacity = {\n        value: opacity\n      };\n    }\n  }\n\n  out = Object.assign(Object.assign({}, out), symbolsSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function gradient(fieldDef, gradientSpec, model, channel, legendCmp) {\n  if (type(legendCmp, model, channel) !== 'gradient') {\n    return undefined;\n  }\n\n  let out = {};\n  const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = {\n      value: opacity\n    };\n  }\n\n  out = Object.assign(Object.assign({}, out), gradientSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\nexport function labels(fieldDef, labelsSpec, model, channel) {\n  const legend = model.legend(channel);\n  const config = model.config;\n  let out = {};\n\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat, isUTCScale);\n    labelsSpec = Object.assign(Object.assign({}, expr ? {\n      text: {\n        signal: expr\n      }\n    } : {}), labelsSpec);\n  }\n\n  out = Object.assign(Object.assign({}, out), labelsSpec);\n  return keys(out).length > 0 ? out : undefined;\n}\n\nfunction getMaxValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => Math.max(v, conditionalDef.value));\n}\n\nexport function getFirstConditionValue(channelDef) {\n  return getConditionValue(channelDef, (v, conditionalDef) => {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue(channelDef, reducer) {\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition]).reduce(reducer, channelDef.value);\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value;\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}