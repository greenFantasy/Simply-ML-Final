{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nconst dom_1 = require(\"../util/dom\");\n\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a barchart.\n *\n * ```js\n * const data = [\n *   { index: 0, value: 50 },\n *   { index: 1, value: 100 },\n *   { index: 2, value: 150 },\n *  ];\n *\n * // Render to visor\n * const surface = { name: 'Bar chart', tab: 'Charts' };\n * tfvis.render.barchart(surface, data);\n * ```\n *\n * @param data Data in the following format, (an array of objects)\n *    `[ {index: number, value: number} ... ]`\n *\n * @returns Promise - indicates completion of rendering\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction barchart(container, data, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const drawArea = render_utils_1.getDrawArea(container);\n    const values = data;\n    const options = Object.assign({}, defaultOpts, opts); // If we have rendered this chart before with the same options we can do a\n    // data only update, else  we do a regular re-render.\n\n    if (instances.has(drawArea)) {\n      const instanceInfo = instances.get(drawArea);\n\n      if (render_utils_1.shallowEquals(options, instanceInfo.lastOptions)) {\n        yield render_utils_1.nextFrame();\n        const view = instanceInfo.view;\n        const changes = view.changeset().remove(() => true).insert(values);\n        yield view.change('values', changes).runAsync();\n        return;\n      }\n    }\n\n    const xLabel = options.xLabel,\n          yLabel = options.yLabel,\n          xType = options.xType,\n          yType = options.yType;\n    let xAxis = null;\n\n    if (xLabel != null) {\n      xAxis = {\n        title: xLabel\n      };\n    }\n\n    let yAxis = null;\n\n    if (yLabel != null) {\n      yAxis = {\n        title: yLabel\n      };\n    }\n\n    const embedOpts = {\n      actions: false,\n      mode: 'vega-lite',\n      defaultStyle: false\n    };\n    const spec = {\n      'width': options.width || dom_1.getDefaultWidth(drawArea),\n      'height': options.height || dom_1.getDefaultHeight(drawArea),\n      'padding': 0,\n      'autosize': {\n        'type': 'fit',\n        'contains': 'padding',\n        'resize': true\n      },\n      'config': {\n        'axis': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'text': {\n          'fontSize': options.fontSize\n        },\n        'legend': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        }\n      },\n      'data': {\n        'values': values,\n        'name': 'values'\n      },\n      'mark': {\n        'type': 'bar',\n        'tooltip': true\n      },\n      'encoding': {\n        'x': {\n          'field': 'index',\n          'type': xType,\n          'axis': xAxis\n        },\n        'y': {\n          'field': 'value',\n          'type': yType,\n          'axis': yAxis\n        }\n      }\n    };\n    yield render_utils_1.nextFrame();\n    const embedRes = yield vega_embed_1.default(drawArea, spec, embedOpts);\n    instances.set(drawArea, {\n      view: embedRes.view,\n      lastOptions: options\n    });\n  });\n}\n\nexports.barchart = barchart;\nconst defaultOpts = {\n  xLabel: '',\n  yLabel: '',\n  xType: 'ordinal',\n  yType: 'quantitative',\n  fontSize: 11\n}; // We keep a map of containers to chart instances in order to reuse the\n// instance where possible.\n\nconst instances = new Map();","map":null,"metadata":{},"sourceType":"script"}