{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst histogram_1 = require(\"../render/histogram\");\n\nconst render_utils_1 = require(\"../render/render_utils\");\n\nconst table_1 = require(\"../render/table\");\n\nconst dom_1 = require(\"../util/dom\");\n\nconst math_1 = require(\"../util/math\");\n/**\n * Renders a summary of a tf.Model. Displays a table with layer information.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * const surface = { name: 'Model Summary', tab: 'Model Inspection'};\n * tfvis.show.modelSummary(surface, model);\n * ```\n *\n */\n\n/**\n * @doc {\n *  heading: 'Models & Tensors',\n *  subheading: 'Model Inspection',\n *  namespace: 'show'\n * }\n */\n\n\nfunction modelSummary(container, model) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const drawArea = render_utils_1.getDrawArea(container);\n    const summary = getModelSummary(model);\n    const headers = ['Layer Name', 'Output Shape', '# Of Params', 'Trainable'];\n    const values = summary.layers.map(l => [l.name, l.outputShape, l.parameters, l.trainable]);\n    table_1.table(drawArea, {\n      headers,\n      values\n    });\n  });\n}\n\nexports.modelSummary = modelSummary;\n/**\n * Renders summary information about a layer and a histogram of parameters in\n * that layer.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * const surface = { name: 'Layer Summary', tab: 'Model Inspection'};\n * tfvis.show.layer(surface, model.getLayer(undefined, 1));\n * ```\n *\n */\n\n/**\n * @doc {\n *  heading: 'Models & Tensors',\n *  subheading: 'Model Inspection',\n *  namespace: 'show'\n * }\n */\n\nfunction layer(container, layer) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const drawArea = render_utils_1.getDrawArea(container);\n    const details = yield getLayerDetails(layer);\n    const headers = ['Weight Name', 'Shape', 'Min', 'Max', '# Params', '# Zeros', '# NaNs', '# Infinity']; // Show layer summary\n\n    const weightsInfoSurface = dom_1.subSurface(drawArea, 'layer-weights-info');\n    const detailValues = details.map(l => [l.name, l.shape, l.stats.min, l.stats.max, l.weight.size, l.stats.numZeros, l.stats.numNans, l.stats.numInfs]);\n    table_1.table(weightsInfoSurface, {\n      headers,\n      values: detailValues\n    });\n    const histogramSelectorSurface = dom_1.subSurface(drawArea, 'select-layer');\n    const layerValuesHistogram = dom_1.subSurface(drawArea, 'param-distribution');\n\n    const handleSelection = layerName => __awaiter(this, void 0, void 0, function* () {\n      const layer = details.filter(d => d.name === layerName)[0];\n      const weights = yield layer.weight.data();\n      histogram_1.histogram(layerValuesHistogram, weights, {\n        height: 150,\n        width: 460,\n        stats: false\n      });\n    });\n\n    addHistogramSelector(details.map(d => d.name), histogramSelectorSurface, handleSelection);\n  });\n}\n\nexports.layer = layer; //\n// Helper functions\n//\n\nfunction getModelSummary(model) {\n  return {\n    layers: model.layers.map(getLayerSummary)\n  };\n}\n/*\n * Gets summary information/metadata about a layer.\n */\n\n\nfunction getLayerSummary(layer) {\n  let outputShape;\n\n  if (Array.isArray(layer.outputShape[0])) {\n    const shapes = layer.outputShape.map(s => formatShape(s));\n    outputShape = \"[\".concat(shapes.join(', '), \"]\");\n  } else {\n    outputShape = formatShape(layer.outputShape);\n  }\n\n  return {\n    name: layer.name,\n    trainable: layer.trainable,\n    parameters: layer.countParams(),\n    outputShape\n  };\n}\n/*\n * Gets summary stats and shape for all weights in a layer.\n */\n\n\nfunction getLayerDetails(layer) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const weights = layer.getWeights();\n    const layerVariables = layer.weights;\n    const statsPromises = weights.map(math_1.tensorStats);\n    const stats = yield Promise.all(statsPromises);\n    const shapes = weights.map(w => w.shape);\n    return weights.map((weight, i) => ({\n      name: layerVariables[i].name,\n      stats: stats[i],\n      shape: formatShape(shapes[i]),\n      weight\n    }));\n  });\n}\n\nfunction formatShape(shape) {\n  const oShape = shape.slice();\n\n  if (oShape.length === 0) {\n    return 'Scalar';\n  }\n\n  if (oShape[0] === null) {\n    oShape[0] = 'batch';\n  }\n\n  return \"[\".concat(oShape.join(','), \"]\");\n}\n\nfunction addHistogramSelector(items, parent, // tslint:disable-next-line:no-any\nselectionHandler) {\n  const select = \"\\n    <select>\\n      \".concat(items.map(i => \"<option value=\".concat(i, \">\").concat(i, \"</option>\")), \"\\n    </select>\\n  \");\n  const button = \"<button>Show Values Distribution for:</button>\";\n  const content = \"<div>\".concat(button).concat(select, \"</div>\");\n  parent.innerHTML = content; // Add listeners\n\n  const buttonEl = parent.querySelector('button');\n  const selectEl = parent.querySelector('select');\n  buttonEl.addEventListener('click', () => {\n    selectionHandler(selectEl.selectedOptions[0].label);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}