{"ast":null,"code":"import { array, isArray, isObject, isString } from 'vega-util';\nimport { isBinned, isBinning } from '../../bin';\nimport { SCALE_CHANNELS, X, X2, Y2 } from '../../channel';\nimport { getTypedFieldDef, isConditionalSelection, isFieldDef, isValueDef } from '../../channeldef';\nimport * as log from '../../log';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { contains, getFirstDefined, keys } from '../../util';\nimport { VG_MARK_CONFIGS } from '../../vega.schema';\nimport { getMarkConfig, getMarkPropOrConfig, getStyleConfig } from '../common';\nimport { expression } from '../predicate';\nimport { parseSelectionPredicate } from '../selection/parse';\nimport * as ref from './valueref';\nimport { fieldInvalidPredicate } from './valueref';\nexport function color(model) {\n  const markDef = model.markDef,\n        encoding = model.encoding,\n        config = model.config;\n  const filled = markDef.filled,\n        markType = markDef.type;\n  const configValue = {\n    fill: getMarkConfig('fill', markDef, config),\n    stroke: getMarkConfig('stroke', markDef, config),\n    color: getMarkConfig('color', markDef, config)\n  };\n  const transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType) ? 'transparent' : undefined;\n  const defaultFill = getFirstDefined(markDef.fill, filled === true ? markDef.color : undefined, configValue.fill, filled === true ? configValue.color : undefined, // If there is no fill, always fill symbols, bar, geoshape\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  transparentIfNeeded);\n  const defaultStroke = getFirstDefined(markDef.stroke, filled === false ? markDef.color : undefined, configValue.stroke, filled === false ? configValue.color : undefined);\n  const colorVgChannel = filled ? 'fill' : 'stroke';\n  const fillStrokeMarkDefAndConfig = Object.assign(Object.assign({}, defaultFill ? {\n    fill: {\n      value: defaultFill\n    }\n  } : {}), defaultStroke ? {\n    stroke: {\n      value: defaultStroke\n    }\n  } : {});\n\n  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {\n    log.warn(log.message.droppingColor('property', {\n      fill: 'fill' in markDef,\n      stroke: 'stroke' in markDef\n    }));\n  }\n\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, fillStrokeMarkDefAndConfig), nonPosition('color', model, {\n    vgChannel: colorVgChannel,\n    defaultValue: filled ? defaultFill : defaultStroke\n  })), nonPosition('fill', model, {\n    // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding\n    defaultValue: encoding.fill ? defaultFill : undefined\n  })), nonPosition('stroke', model, {\n    // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding\n    defaultValue: encoding.stroke ? defaultStroke : undefined\n  }));\n}\nexport function baseEncodeEntry(model, ignore) {\n  const _ref = ignore.color === 'include' ? color(model) : {},\n        _ref$fill = _ref.fill,\n        fill = _ref$fill === void 0 ? undefined : _ref$fill,\n        _ref$stroke = _ref.stroke,\n        stroke = _ref$stroke === void 0 ? undefined : _ref$stroke;\n\n  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, markDefProperties(model.markDef, ignore)), wrapAllFieldsInvalid(model, 'fill', fill)), wrapAllFieldsInvalid(model, 'stroke', stroke)), nonPosition('opacity', model)), nonPosition('fillOpacity', model)), nonPosition('strokeOpacity', model)), nonPosition('strokeWidth', model)), tooltip(model)), text(model, 'href'));\n} // TODO: mark VgValueRef[] as readonly after https://github.com/vega/vega/pull/1987\n\nfunction wrapAllFieldsInvalid(model, channel, valueRef) {\n  const config = model.config,\n        mark = model.mark,\n        markDef = model.markDef;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {\n      invalid: true,\n      channels: SCALE_CHANNELS\n    });\n\n    if (test) {\n      return {\n        [channel]: [// prepend the invalid case\n        // TODO: support custom value\n        {\n          test,\n          value: null\n        }, ...array(valueRef)]\n      };\n    }\n  }\n\n  return valueRef ? {\n    [channel]: valueRef\n  } : {};\n}\n\nfunction markDefProperties(mark, ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {\n        value: mark[prop]\n      };\n    }\n\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop, value) {\n  if (value !== undefined) {\n    return {\n      [prop]: {\n        value: value\n      }\n    };\n  }\n\n  return undefined;\n}\n\nfunction allFieldsInvalidPredicate(model, {\n  invalid = false,\n  channels\n}) {\n  const filterIndex = channels.reduce((aggregator, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {\n        expr: 'datum'\n      }); // While discrete domain scales can handle invalid values, continuous scales can't.\n\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n\n    return aggregator;\n  }, {});\n  const fields = keys(filterIndex);\n\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(\" \".concat(op, \" \"));\n  }\n\n  return undefined;\n}\n\nexport function defined(model) {\n  const config = model.config,\n        markDef = model.markDef;\n  const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n  if (invalid) {\n    const signal = allFieldsInvalidPredicate(model, {\n      channels: ['x', 'y']\n    });\n\n    if (signal) {\n      return {\n        defined: {\n          signal\n        }\n      };\n    }\n  }\n\n  return {};\n}\n/**\n * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)\n */\n\nexport function nonPosition(channel, model, opt = {}) {\n  const markDef = model.markDef,\n        encoding = model.encoding,\n        config = model.config;\n  const _opt$vgChannel = opt.vgChannel,\n        vgChannel = _opt$vgChannel === void 0 ? channel : _opt$vgChannel;\n  let defaultRef = opt.defaultRef,\n      defaultValue = opt.defaultValue;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue = defaultValue || (vgChannel === channel ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly\n    markDef[channel] : // However, when they are different (e.g, vl's text size is vg fontSize), need to read \"size\" from configs\n    getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, {\n      vgChannel\n    })));\n    defaultRef = defaultValue ? {\n      value: defaultValue\n    } : undefined;\n  }\n\n  const channelDef = encoding[channel];\n  return wrapCondition(model, channelDef, vgChannel, cDef => {\n    return ref.midPoint({\n      channel,\n      channelDef: cDef,\n      markDef,\n      config,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null,\n      defaultRef\n    });\n  });\n}\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\n\nexport function wrapCondition(model, channelDef, vgChannel, refFn) {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n\n  if (condition) {\n    const conditions = array(condition);\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c) ? parseSelectionPredicate(model, c.selection) : expression(model, c.test);\n      return Object.assign({\n        test\n      }, conditionValueRef);\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {\n      [vgChannel]: valueRef\n    } : {};\n  }\n}\nexport function tooltip(model, opt = {}) {\n  const encoding = model.encoding,\n        markDef = model.markDef,\n        config = model.config;\n  const channelDef = encoding.tooltip;\n\n  if (isArray(channelDef)) {\n    return {\n      tooltip: ref.tooltipForEncoding({\n        tooltip: channelDef\n      }, config, opt)\n    };\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = ref.text(cDef, model.config, opt.reactiveGeom ? 'datum.datum' : 'datum');\n\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      } // If tooltipDef does not exist, then use value from markDef or config\n\n\n      let markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n\n      if (markTooltip === true) {\n        markTooltip = {\n          content: 'encoding'\n        };\n      }\n\n      if (isString(markTooltip)) {\n        return {\n          value: markTooltip\n        };\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return ref.tooltipForEncoding(encoding, config, opt);\n        } else {\n          return {\n            signal: 'datum'\n          };\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\nexport function text(model, channel = 'text') {\n  const channelDef = model.encoding[channel];\n  return wrapCondition(model, channelDef, channel, cDef => ref.text(cDef, model.config));\n}\nexport function bandPosition(fieldDef, channel, model, defaultSizeRef) {\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  if (model.encoding.size || model.markDef.size !== undefined || defaultSizeRef && defaultSizeRef.value !== undefined) {\n    const orient = model.markDef.orient;\n\n    if (orient) {\n      const centeredBandPositionMixins = {\n        // Use xc/yc and place the mark at the middle of the band\n        // This way we never have to deal with size's condition for x/y position.\n        [channel + 'c']: ref.fieldRef(fieldDef, scaleName, {}, {\n          band: 0.5\n        })\n      };\n\n      if (getTypedFieldDef(model.encoding.size)) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), nonPosition('size', model, {\n          vgChannel: sizeChannel\n        }));\n      } else if (isValueDef(model.encoding.size)) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), nonPosition('size', model, {\n          vgChannel: sizeChannel\n        }));\n      } else if (model.markDef.size !== undefined) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), {\n          [sizeChannel]: {\n            value: model.markDef.size\n          }\n        });\n      } else if (defaultSizeRef && defaultSizeRef.value !== undefined) {\n        return Object.assign(Object.assign({}, centeredBandPositionMixins), {\n          [sizeChannel]: defaultSizeRef\n        });\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(model.markDef.type));\n    }\n  }\n\n  const _fieldDef$band = fieldDef.band,\n        band = _fieldDef$band === void 0 ? 1 : _fieldDef$band;\n  return {\n    // FIXME: make offset work correctly here when we support group bar (https://github.com/vega/vega-lite/issues/396)\n    [channel]: ref.fieldRef(fieldDef, scaleName, {\n      binSuffix: 'range'\n    }, {\n      band: (1 - band) / 2\n    }),\n    [sizeChannel]: defaultSizeRef || ref.bandRef(scaleName, band)\n  };\n}\nexport function centeredPointPositionWithSize(channel, model, defaultPosRef, defaultSizeRef) {\n  const centerChannel = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return Object.assign(Object.assign({}, pointPosition(channel, model, defaultPosRef, {\n    vgChannel: centerChannel\n  })), nonPosition('size', model, {\n    defaultRef: defaultSizeRef,\n    vgChannel: sizeChannel\n  }));\n}\nexport function binPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  band,\n  scaleName,\n  markDef,\n  spacing = 0,\n  reverse\n}) {\n  const binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  };\n  const channel2 = channel === X ? X2 : Y2;\n\n  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {\n    return {\n      [channel2]: ref.bin({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: (1 - band) / 2,\n        offset: binSpacing[\"\".concat(channel, \"2\")]\n      }),\n      [channel]: ref.bin({\n        channel,\n        fieldDef,\n        scaleName,\n        markDef,\n        band: 1 - (1 - band) / 2,\n        offset: binSpacing[channel]\n      })\n    };\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    return {\n      [channel2]: ref.fieldRef(fieldDef, scaleName, {}, {\n        offset: binSpacing[\"\".concat(channel, \"2\")]\n      }),\n      [channel]: ref.fieldRef(fieldDef2, scaleName, {}, {\n        offset: binSpacing[channel]\n      })\n    };\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n/**\n * Return mixins for point (non-band) position channels.\n */\n\nexport function pointPosition(channel, model, defaultRef, {\n  vgChannel\n} = {}) {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n  const encoding = model.encoding,\n        mark = model.mark,\n        markDef = model.markDef,\n        config = model.config,\n        stack = model.stack;\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[channel === X ? X2 : Y2];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n  const offset = ref.getOffset(channel, model.markDef);\n  const valueRef = !channelDef && (encoding.latitude || encoding.longitude) ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n  {\n    field: model.getName(channel)\n  } : ref.position({\n    channel,\n    channelDef,\n    channel2Def,\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: ref.positionDefault({\n      markDef,\n      config,\n      defaultRef,\n      channel,\n      scaleName,\n      scale,\n      mark,\n      checkBarAreaWithoutZero: !channel2Def // only check for non-ranged marks\n\n    })\n  });\n  return {\n    [vgChannel || channel]: valueRef\n  };\n}\nconst ALIGNED_X_CHANNEL = {\n  left: 'x',\n  center: 'xc',\n  right: 'x2'\n};\nconst BASELINED_Y_CHANNEL = {\n  top: 'y',\n  middle: 'yc',\n  bottom: 'y2'\n};\nexport function pointOrRangePosition(channel, model, {\n  defaultRef,\n  defaultRef2,\n  range\n}) {\n  if (range) {\n    return rangePosition(channel, model, {\n      defaultRef,\n      defaultRef2\n    });\n  }\n\n  return pointPosition(channel, model, defaultRef);\n}\nexport function rangePosition(channel, model, {\n  defaultRef,\n  defaultRef2\n}) {\n  const markDef = model.markDef,\n        config = model.config;\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  const pos2Mixins = pointPosition2(model, defaultRef2, channel2);\n  const vgChannel = pos2Mixins[sizeChannel] ? alignedChannel(channel, markDef, config) : channel;\n  return Object.assign(Object.assign({}, pointPosition(channel, model, defaultRef, {\n    vgChannel\n  })), pos2Mixins);\n}\n\nfunction alignedChannel(channel, markDef, config) {\n  const alignChannel = channel === 'x' ? 'align' : 'baseline';\n  const align = getFirstDefined(markDef[alignChannel], getMarkConfig(alignChannel, markDef, config));\n\n  if (channel === 'x') {\n    return ALIGNED_X_CHANNEL[align || 'center'];\n  } else {\n    return BASELINED_Y_CHANNEL[align || 'middle'];\n  }\n}\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\n\n\nfunction pointPosition2(model, defaultRef, channel) {\n  const encoding = model.encoding,\n        mark = model.mark,\n        markDef = model.markDef,\n        stack = model.stack,\n        config = model.config;\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n  const offset = ref.getOffset(channel, model.markDef);\n\n  if (!channelDef && (encoding.latitude || encoding.longitude)) {\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    return {\n      [channel]: {\n        field: model.getName(channel)\n      }\n    };\n  }\n\n  const valueRef = ref.position2({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    markDef,\n    config,\n    scaleName,\n    scale,\n    stack,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {\n      [channel]: valueRef\n    };\n  } // TODO: check width/height encoding here once we add them\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n\n  return getFirstDefined(position2orSize(channel, markDef), position2orSize(channel, {\n    [channel]: getStyleConfig(channel, markDef, config.style),\n    [sizeChannel]: getStyleConfig(sizeChannel, markDef, config.style)\n  }), position2orSize(channel, config[mark]), position2orSize(channel, config.mark), {\n    [channel]: ref.positionDefault({\n      markDef,\n      config,\n      defaultRef,\n      channel,\n      scaleName,\n      scale,\n      mark,\n      checkBarAreaWithoutZero: !encoding[channel] // only check for non-ranged marks\n\n    })()\n  });\n}\n\nfunction position2orSize(channel, markDef) {\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n\n  if (markDef[channel]) {\n    return {\n      [channel]: ref.vgValueRef(channel, markDef[channel])\n    };\n  } else if (markDef[sizeChannel]) {\n    return {\n      [sizeChannel]: {\n        value: markDef[sizeChannel]\n      }\n    };\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}