{"ast":null,"code":"import * as log from '../log';\nimport { duplicate, getFirstDefined, keys, stringify } from '../util';\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\n\nexport class Split {\n  constructor(explicit = {}, implicit = {}) {\n    this.explicit = explicit;\n    this.implicit = implicit;\n  }\n\n  clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  combine() {\n    // FIXME remove \"as any\".\n    // Add \"as any\" to avoid an error \"Spread types may only be created from object types\".\n    return Object.assign(Object.assign({}, this.explicit), this.implicit);\n  }\n\n  get(key) {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  getWithExplicit(key) {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {\n        explicit: true,\n        value: this.explicit[key]\n      };\n    } else if (this.implicit[key] !== undefined) {\n      return {\n        explicit: false,\n        value: this.implicit[key]\n      };\n    }\n\n    return {\n      explicit: false,\n      value: undefined\n    };\n  }\n\n  setWithExplicit(key, value) {\n    if (value.value !== undefined) {\n      this.set(key, value.value, value.explicit);\n    }\n  }\n\n  set(key, value, explicit) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  copyKeyFromSplit(key, s) {\n    // Explicit has higher precedence\n    if (s.explicit[key] !== undefined) {\n      this.set(key, s.explicit[key], true);\n    } else if (s.implicit[key] !== undefined) {\n      this.set(key, s.implicit[key], false);\n    }\n  }\n\n  copyKeyFromObject(key, s) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n\n\n  copyAll(other) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n\n}\nexport function makeExplicit(value) {\n  return {\n    explicit: true,\n    value\n  };\n}\nexport function makeImplicit(value) {\n  return {\n    explicit: false,\n    value\n  };\n}\nexport function tieBreakByComparing(compare) {\n  return (v1, v2, property, propertyOf) => {\n    const diff = compare(v1.value, v2.value);\n\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n\n    return defaultTieBreaker(v1, v2, property, propertyOf);\n  };\n}\nexport function defaultTieBreaker(v1, v2, property, propertyOf) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  } // If equal score, prefer v1.\n\n\n  return v1;\n}\nexport function mergeValuesWithExplicit(v1, v2, property, propertyOf, tieBreaker = defaultTieBreaker) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (stringify(v1.value) === stringify(v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}