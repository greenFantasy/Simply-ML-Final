{"ast":null,"code":"import { extend, error, isFunction, stringValue } from 'vega-util'; // Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\n\nconst protocol_re = /^([A-Za-z]+:)?\\/\\//; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://\n\nconst allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i; // eslint-disable-line no-useless-escape\n\nconst whitespace_re = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g; // eslint-disable-line no-control-regex\n// Special treatment in node.js for the file: protocol\n\nconst fileProtocol = 'file://';\n/**\n * Factory for a loader constructor that provides methods for requesting\n * files from either the network or disk, and for sanitizing request URIs.\n * @param {function} fetch - The Fetch API for HTTP network requests.\n *   If null or undefined, HTTP loading will be disabled.\n * @param {object} fs - The file system interface for file loading.\n *   If null or undefined, local file loading will be disabled.\n * @return {function} A loader constructor with the following signature:\n *   param {object} [options] - Optional default loading options to use.\n *   return {object} - A new loader instance.\n */\n\nexport default function (fetch, fs) {\n  return function (options) {\n    return {\n      options: options || {},\n      sanitize: sanitize,\n      load: load,\n      fileAccess: !!fs,\n      file: fileLoader(fs),\n      http: httpLoader(fetch)\n    };\n  };\n}\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\n\nasync function load(uri, options) {\n  const opt = await this.sanitize(uri, options),\n        url = opt.href;\n  return opt.localFile ? this.file(url) : this.http(url, options);\n}\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to sanity check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\n\n\nasync function sanitize(uri, options) {\n  options = extend({}, this.options, options);\n  const fileAccess = this.fileAccess,\n        result = {\n    href: null\n  };\n  let isFile, loadFile, base;\n  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));\n\n  if (uri == null || typeof uri !== 'string' || !isAllowed) {\n    error('Sanitize failure, invalid URI: ' + stringValue(uri));\n  }\n\n  const hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL\n\n  if ((base = options.baseURL) && !hasProtocol) {\n    // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    if (!uri.startsWith('/') && base[base.length - 1] !== '/') {\n      uri = '/' + uri;\n    }\n\n    uri = base + uri;\n  } // should we load from file system?\n\n\n  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;\n\n  if (isFile) {\n    // strip file protocol\n    uri = uri.slice(fileProtocol.length);\n  } else if (uri.startsWith('//')) {\n    if (options.defaultProtocol === 'file') {\n      // if is file, strip protocol and set loadFile flag\n      uri = uri.slice(2);\n      loadFile = true;\n    } else {\n      // if relative protocol (starts with '//'), prepend default protocol\n      uri = (options.defaultProtocol || 'http') + ':' + uri;\n    }\n  } // set non-enumerable mode flag to indicate local file load\n\n\n  Object.defineProperty(result, 'localFile', {\n    value: !!loadFile\n  }); // set uri\n\n  result.href = uri; // set default result target, if specified\n\n  if (options.target) {\n    result.target = options.target + '';\n  } // set default result rel, if specified (#1542)\n\n\n  if (options.rel) {\n    result.rel = options.rel + '';\n  } // return\n\n\n  return result;\n}\n/**\n * File system loader factory.\n * @param {object} fs - The file system interface.\n * @return {function} - A file loader with the following signature:\n *   param {string} filename - The file system path to load.\n *   param {string} filename - The file system path to load.\n *   return {Promise} A promise that resolves to the file contents.\n */\n\n\nfunction fileLoader(fs) {\n  return fs ? function (filename) {\n    return new Promise(function (accept, reject) {\n      fs.readFile(filename, function (error, data) {\n        if (error) reject(error);else accept(data);\n      });\n    });\n  } : fileReject;\n}\n/**\n * Default file system loader that simply rejects.\n */\n\n\nasync function fileReject() {\n  error('No file system access.');\n}\n/**\n * HTTP request handler factory.\n * @param {function} fetch - The Fetch API method.\n * @return {function} - An http loader with the following signature:\n *   param {string} url - The url to request.\n *   param {object} options - An options hash.\n *   return {Promise} - A promise that resolves to the file contents.\n */\n\n\nfunction httpLoader(fetch) {\n  return fetch ? async function (url, options) {\n    const opt = extend({}, this.options.http, options),\n          type = options && options.response,\n          response = await fetch(url, opt);\n    return !response.ok ? error(response.status + '' + response.statusText) : isFunction(response[type]) ? response[type]() : response.text();\n  } : httpReject;\n}\n/**\n * Default http request handler that simply rejects.\n */\n\n\nasync function httpReject() {\n  error('No HTTP fetch method available.');\n}","map":null,"metadata":{},"sourceType":"module"}