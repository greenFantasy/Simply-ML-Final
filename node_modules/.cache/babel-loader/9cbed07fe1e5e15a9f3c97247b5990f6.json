{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { AXIS_PARTS, AXIS_PROPERTY_TYPE, CONDITIONAL_AXIS_PROP_INDEX, isConditionalAxisValue } from '../../axis';\nimport { POSITION_SCALE_CHANNELS } from '../../channel';\nimport { defaultTitle } from '../../channeldef';\nimport { getFirstDefined, keys, replaceAll } from '../../util';\nimport { isSignalRef } from '../../vega.schema';\nimport { expression } from '../predicate';\n\nfunction assembleTitle(title, config) {\n  if (isArray(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n\n  return title;\n}\n\nfunction setAxisEncode(axis, part, vgProp, vgRef) {\n  axis.encode = axis.encode || {};\n  axis.encode[part] = axis.encode[part] || {};\n  axis.encode[part].update = axis.encode[part].update || {}; // TODO: remove as any after https://github.com/prisma/nexus-prisma/issues/291\n\n  axis.encode[part].update[vgProp] = vgRef;\n}\n\nexport function assembleAxis(axisCmpt, kind, config, opt = {\n  header: false\n}) {\n  const _a = axisCmpt.combine(),\n        orient = _a.orient,\n        scale = _a.scale,\n        labelExpr = _a.labelExpr,\n        title = _a.title,\n        zindex = _a.zindex,\n        axis = __rest(_a, [\"orient\", \"scale\", \"labelExpr\", \"title\", \"zindex\"]); // Remove properties that are not valid for this kind of axis\n\n\n  keys(axis).forEach(prop => {\n    const propType = AXIS_PROPERTY_TYPE[prop];\n    const propValue = axis[prop];\n\n    if (propType && propType !== kind && propType !== 'both') {\n      delete axis[prop];\n    } else if (isConditionalAxisValue(propValue)) {\n      const _CONDITIONAL_AXIS_PRO = CONDITIONAL_AXIS_PROP_INDEX[prop],\n            vgProp = _CONDITIONAL_AXIS_PRO.vgProp,\n            part = _CONDITIONAL_AXIS_PRO.part;\n      const condition = propValue.condition,\n            value = propValue.value;\n      const vgRef = [...(isArray(condition) ? condition : [condition]).map(c => {\n        const v = c.value,\n              test = c.test;\n        return {\n          test: expression(null, test),\n          value: v\n        };\n      }), {\n        value\n      }];\n      setAxisEncode(axis, part, vgProp, vgRef);\n      delete axis[prop];\n    }\n  });\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const grid = axis.encode.grid;\n      axis.encode = Object.assign({}, grid ? {\n        grid\n      } : {});\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    return Object.assign(Object.assign({\n      scale,\n      orient\n    }, axis), {\n      domain: false,\n      labels: false,\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n\n    });\n  } else {\n    // kind === 'main'\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    if (labelExpr !== undefined) {\n      let expr = labelExpr;\n\n      if (axis.encode && axis.encode.labels && axis.encode.labels.update && isSignalRef(axis.encode.labels.update.text)) {\n        expr = replaceAll(labelExpr, 'datum.label', axis.encode.labels.update.text.signal);\n      }\n\n      setAxisEncode(axis, 'labels', 'text', {\n        signal: expr\n      });\n    } // Remove unnecessary encode block\n\n\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n    return Object.assign(Object.assign(Object.assign({\n      scale,\n      orient,\n      grid: false\n    }, titleString ? {\n      title: titleString\n    } : {}), axis), {\n      zindex: getFirstDefined(zindex, 0) // put axis line above marks by default\n\n    });\n  }\n}\n/**\n * Add axis signals so grid line works correctly\n * (Fix https://github.com/vega/vega-lite/issues/4226)\n */\n\nexport function assembleAxisSignals(model) {\n  const axes = model.component.axes;\n\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    if (axes[channel]) {\n      for (const axis of axes[channel]) {\n        if (!axis.get('gridScale')) {\n          // If there is x-axis but no y-scale for gridScale, need to set height/weight so x-axis can draw the grid with the right height.  Same for y-axis and width.\n          const sizeType = channel === 'x' ? 'height' : 'width';\n          return [{\n            name: sizeType,\n            update: model.getSizeSignalRef(sizeType).signal\n          }];\n        }\n      }\n    }\n  }\n\n  return [];\n}\nexport function assembleAxes(axisComponents, config) {\n  const _axisComponents$x = axisComponents.x,\n        x = _axisComponents$x === void 0 ? [] : _axisComponents$x,\n        _axisComponents$y = axisComponents.y,\n        y = _axisComponents$y === void 0 ? [] : _axisComponents$y;\n  return [...x.map(a => assembleAxis(a, 'grid', config)), ...y.map(a => assembleAxis(a, 'grid', config)), ...x.map(a => assembleAxis(a, 'main', config)), ...y.map(a => assembleAxis(a, 'main', config))].filter(a => a); // filter undefined\n}","map":null,"metadata":{},"sourceType":"module"}