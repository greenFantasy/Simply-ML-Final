{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { hasOwnProperty, isString, stringValue } from 'vega-util';\nimport { STORE } from '.';\nimport { duplicate, logicalExpr, varName } from '../../util';\nimport { forEachTransform } from './transforms/transforms';\nexport function parseUnitSelection(model, selDefs) {\n  const selCmpts = {};\n  const selectionConfig = model.config.selection;\n\n  for (let name in selDefs) {\n    if (!hasOwnProperty(selDefs, name)) {\n      continue;\n    }\n\n    const selDef = duplicate(selDefs[name]);\n\n    const _a = selectionConfig[selDef.type],\n          fields = _a.fields,\n          encodings = _a.encodings,\n          cfg = __rest(_a, [\"fields\", \"encodings\"]); // Project transform applies its defaults.\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n\n\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if (key === 'encodings' && selDef.fields || key === 'fields' && selDef.encodings) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = Object.assign(Object.assign({}, cfg[key]), selDef[key]);\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] || selDef[key];\n      }\n    }\n\n    name = varName(name);\n    const selCmpt = selCmpts[name] = Object.assign(Object.assign({}, selDef), {\n      name: name,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on\n    });\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.parse) {\n        txCompiler.parse(model, selCmpt, selDef, selDefs[name]);\n      }\n    });\n  }\n\n  return selCmpts;\n}\nexport function parseSelectionPredicate(model, selections, dfnode) {\n  const stores = [];\n\n  function expr(name) {\n    const vname = varName(name);\n    const selCmpt = model.getSelectionComponent(vname, name);\n    const store = stringValue(vname + STORE);\n\n    if (selCmpt.project.timeUnit) {\n      const child = dfnode || model.component.data.raw;\n      const tunode = selCmpt.project.timeUnit.clone();\n\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return \"vlSelectionTest(\".concat(store, \", datum\") + (selCmpt.resolve === 'global' ? ')' : \", \".concat(stringValue(selCmpt.resolve), \")\"));\n  }\n\n  const predicateStr = logicalExpr(selections, expr);\n  return (stores.length ? '!(' + stores.map(s => \"length(data(\".concat(s, \"))\")).join(' || ') + ') || ' : '') + \"(\".concat(predicateStr, \")\");\n}","map":null,"metadata":{},"sourceType":"module"}