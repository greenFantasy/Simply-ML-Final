{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray } from 'vega-util';\nimport { isArgmaxDef, isArgminDef } from './aggregate';\nimport { isBinned, isBinning } from './bin';\nimport { CHANNELS, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, supportMark } from './channel';\nimport { binRequiresRange, getFieldDef, getGuide, getTypedFieldDef, hasConditionalFieldDef, isConditionalDef, isFieldDef, isTypedFieldDef, isValueDef, normalize, normalizeFieldDef, title, vgField } from './channeldef';\nimport * as log from './log';\nimport { getDateTimeComponents } from './timeunit';\nimport { TEMPORAL } from './type';\nimport { keys, some } from './util';\nexport function channelHasField(encoding, channel) {\n  const channelDef = encoding && encoding[channel];\n\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n\n  return false;\n}\nexport function isAggregate(encoding) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n\n    return false;\n  });\n}\nexport function extractTransformsFromEncoding(oldEncoding, config) {\n  const groupby = [];\n  const bins = [];\n  const timeUnits = [];\n  const aggregate = [];\n  const encoding = {};\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const field = channelDef.field,\n            aggOp = channelDef.aggregate,\n            timeUnit = channelDef.timeUnit,\n            bin = channelDef.bin,\n            remaining = __rest(channelDef, [\"field\", \"aggregate\", \"timeUnit\", \"bin\"]);\n\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide && guide.title;\n        let newField = vgField(channelDef, {\n          forAs: true\n        });\n        const newFieldDef = Object.assign(Object.assign(Object.assign({}, isTitleDefined ? [] : {\n          title: title(channelDef, config, {\n            allowDisabling: true\n          })\n        }), remaining), {\n          // Always overwrite field\n          field: newField\n        });\n        const isPositionChannel = channel === 'x' || channel === 'y';\n\n        if (aggOp) {\n          let op;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({\n              op: 'argmax',\n              field: aggOp.argmax\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = \"\".concat(newField, \".\").concat(field);\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({\n              op: 'argmin',\n              field: aggOp.argmin\n            }, {\n              forAs: true\n            });\n            newFieldDef.field = \"\".concat(newField, \".\").concat(field);\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            const aggregateEntry = {\n              op,\n              as: newField\n            };\n\n            if (field) {\n              aggregateEntry.field = field;\n            }\n\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({\n              bin,\n              field,\n              as: newField\n            }); // Add additional groupbys for range and end of bins\n\n            groupby.push(vgField(channelDef, {\n              binSuffix: 'end'\n            }));\n\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {\n                binSuffix: 'range'\n              }));\n            } // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n\n\n            if (isPositionChannel) {\n              const secondaryChannel = {\n                field: newField + '_end'\n              };\n              encoding[channel + '2'] = secondaryChannel;\n            }\n\n            newFieldDef.bin = 'binned';\n\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = 'quantitative';\n            }\n          } else if (timeUnit) {\n            timeUnits.push({\n              timeUnit,\n              field,\n              as: newField\n            }); // Add formatting to appropriate property based on the type of channel we're processing\n\n            const format = getDateTimeComponents(timeUnit, config.axis.shortTimeLabels).join(' ');\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n\n            if (channel === 'text' || channel === 'tooltip') {\n              newFieldDef['format'] = newFieldDef['format'] || format;\n\n              if (formatType) {\n                newFieldDef['formatType'] = formatType;\n              }\n            } else if (isNonPositionScaleChannel(channel)) {\n              newFieldDef['legend'] = Object.assign(Object.assign({\n                format\n              }, formatType ? {\n                formatType\n              } : {}), newFieldDef['legend']);\n            } else if (isPositionChannel) {\n              newFieldDef['axis'] = Object.assign(Object.assign({\n                format\n              }, formatType ? {\n                formatType\n              } : {}), newFieldDef['axis']);\n            }\n          }\n        } // now the field should refer to post-transformed field instead\n\n\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\nexport function markChannelCompatible(encoding, channel, mark) {\n  const markSupported = supportMark(channel, mark);\n\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === 'x2' ? 'x' : 'y']; // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function normalizeEncoding(encoding, markDef) {\n  const mark = markDef.type;\n  return keys(encoding).reduce((normalizedEncoding, channel) => {\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    } // Drop line's size if the field is aggregated.\n\n\n    if (channel === 'size' && mark === 'line') {\n      const fieldDef = getTypedFieldDef(encoding[channel]);\n\n      if (fieldDef && fieldDef.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    } // Drop color if either fill or stroke is specified\n\n\n    if (channel === 'color' && (markDef.filled ? 'fill' in encoding : 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {\n        fill: 'fill' in encoding,\n        stroke: 'stroke' in encoding\n      }));\n      return normalizedEncoding;\n    }\n\n    const channelDef = encoding[channel];\n\n    if (channel === 'detail' || channel === 'order' && !isArray(channelDef) && !isValueDef(channelDef) || channel === 'tooltip' && isArray(channelDef)) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = (isArray(channelDef) ? channelDef : [channelDef]).reduce((defs, fieldDef) => {\n          if (!isFieldDef(fieldDef)) {\n            log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          } else {\n            defs.push(normalizeFieldDef(fieldDef, channel));\n          }\n\n          return defs;\n        }, []);\n      }\n    } else {\n      if (channel === 'tooltip' && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n\n      normalizedEncoding[channel] = normalize(channelDef, channel);\n    }\n\n    return normalizedEncoding;\n  }, {});\n}\nexport function fieldDefs(encoding) {\n  const arr = [];\n\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      const channelDefArray = isArray(channelDef) ? channelDef : [channelDef];\n\n      for (const def of channelDefArray) {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      }\n    }\n  }\n\n  return arr;\n}\nexport function forEach(mapping, f, thisArg) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n\n    if (isArray(el)) {\n      el.forEach(channelDef => {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\nexport function reduce(mapping, f, init, thisArg) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n\n    if (isArray(map)) {\n      return map.reduce((r1, channelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n/**\n * Returns list of path grouping fields for the given encoding\n */\n\nexport function pathGroupingFields(mark, encoding) {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'href':\n      case 'url':\n      case 'x2':\n      case 'y2': // falls through\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2': // TODO: case 'cursor':\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n\n      case 'text':\n      case 'shape': // falls through\n      // tooltip fields should not be added to group by [falls through]\n\n      case 'tooltip':\n        return details;\n\n      case 'order':\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n\n      // but order should group area for stacking (falls through)\n\n      case 'detail':\n      case 'key':\n        {\n          const channelDef = encoding[channel];\n\n          if (isArray(channelDef) || isFieldDef(channelDef)) {\n            (isArray(channelDef) ? channelDef : [channelDef]).forEach(fieldDef => {\n              if (!fieldDef.aggregate) {\n                details.push(vgField(fieldDef, {}));\n              }\n            });\n          }\n\n          return details;\n        }\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n\n      // For line, size should group lines.\n      // falls through\n\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      case 'fillOpacity':\n      case 'strokeOpacity':\n      case 'strokeWidth':\n        {\n          // TODO strokeDashOffset:\n          // falls through\n          const fieldDef = getTypedFieldDef(encoding[channel]);\n\n          if (fieldDef && !fieldDef.aggregate) {\n            details.push(vgField(fieldDef, {}));\n          }\n\n          return details;\n        }\n    }\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}