{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nconst dom_1 = require(\"../util/dom\");\n\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a scatter plot\n *\n * ```js\n * const series1 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 50))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series2 = Array(100).fill(0)\n *   .map(y => Math.random() * 100 - (Math.random() * 150))\n *   .map((y, x) => ({ x, y, }));\n *\n * const series = ['First', 'Second'];\n * const data = { values: [series1, series2], series }\n *\n * const surface = { name: 'Scatterplot', tab: 'Charts' };\n * tfvis.render.scatterplot(surface, data);\n * ```\n *\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction scatterplot(container, data, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let _values = data.values;\n\n    const _series = data.series == null ? [] : data.series; // Nest data if necessary before further processing\n\n\n    _values = Array.isArray(_values[0]) ? _values : [_values];\n    const values = [];\n\n    _values.forEach((seriesData, i) => {\n      const seriesName = _series[i] != null ? _series[i] : \"Series \".concat(i + 1);\n      const seriesVals = seriesData.map(v => Object.assign({}, v, {\n        series: seriesName\n      }));\n      values.push(...seriesVals);\n    });\n\n    const drawArea = render_utils_1.getDrawArea(container);\n    const options = Object.assign({}, defaultOpts, opts);\n    const embedOpts = {\n      actions: false,\n      mode: 'vega-lite',\n      defaultStyle: false\n    };\n\n    const xDomain = () => {\n      if (options.zoomToFit) {\n        return {\n          'zero': false\n        };\n      } else if (options.xAxisDomain != null) {\n        return {\n          'domain': options.xAxisDomain\n        };\n      }\n\n      return undefined;\n    };\n\n    const yDomain = () => {\n      if (options.zoomToFit) {\n        return {\n          'zero': false\n        };\n      } else if (options.yAxisDomain != null) {\n        return {\n          'domain': options.yAxisDomain\n        };\n      }\n\n      return undefined;\n    };\n\n    const spec = {\n      'width': options.width || dom_1.getDefaultWidth(drawArea),\n      'height': options.height || dom_1.getDefaultHeight(drawArea),\n      'padding': 0,\n      'autosize': {\n        'type': 'fit',\n        'contains': 'padding',\n        'resize': true\n      },\n      'config': {\n        'axis': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'text': {\n          'fontSize': options.fontSize\n        },\n        'legend': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        }\n      },\n      'data': {\n        'values': values\n      },\n      'mark': {\n        'type': 'point',\n        'clip': true,\n        'tooltip': {\n          'content': 'data'\n        }\n      },\n      'encoding': {\n        'x': {\n          'field': 'x',\n          'type': options.xType,\n          'title': options.xLabel,\n          'scale': xDomain()\n        },\n        'y': {\n          'field': 'y',\n          'type': options.yType,\n          'title': options.yLabel,\n          'scale': yDomain()\n        },\n        'color': {\n          'field': 'series',\n          'type': 'nominal'\n        },\n        'shape': {\n          'field': 'series',\n          'type': 'nominal'\n        }\n      }\n    };\n    yield vega_embed_1.default(drawArea, spec, embedOpts);\n    return Promise.resolve();\n  });\n}\n\nexports.scatterplot = scatterplot;\nconst defaultOpts = {\n  xLabel: 'x',\n  yLabel: 'y',\n  xType: 'quantitative',\n  yType: 'quantitative',\n  zoomToFit: false,\n  fontSize: 11\n};","map":null,"metadata":{},"sourceType":"script"}