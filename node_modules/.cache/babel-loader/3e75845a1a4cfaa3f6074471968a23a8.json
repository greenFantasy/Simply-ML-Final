{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { array, isArray } from 'vega-util';\nimport { isSingleDefUnitChannel } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { hash, keys, varName, replacePathInField, duplicate } from '../../../util';\nimport { TimeUnitNode } from '../../data/timeunit';\nexport const TUPLE_FIELDS = '_tuple_fields';\nexport class SelectionProjectionComponent {\n  constructor(...items) {\n    this.items = items;\n    this.has = {};\n  }\n\n}\nconst project = {\n  has: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n  parse: (model, selCmpt, selDef) => {\n    const name = selCmpt.name;\n    const proj = selCmpt.project || (selCmpt.project = new SelectionProjectionComponent());\n    const parsed = {};\n    const timeUnits = {};\n    const signals = new Set();\n\n    const signalName = (p, range) => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(\"\".concat(name, \"_\").concat(suffix));\n\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(\"\".concat(name, \"_\").concat(suffix, \"_\").concat(counter));\n      }\n\n      signals.add(sg);\n      return {\n        [range]: sg\n      };\n    }; // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    // Otherwise, use the default configuration.\n\n\n    if (!selDef.fields && !selDef.encodings) {\n      const cfg = model.config.selection[selDef.type];\n\n      if (selDef.init) {\n        for (const init of array(selDef.init)) {\n          for (const key of keys(init)) {\n            if (isSingleDefUnitChannel(key)) {\n              (selDef.encodings || (selDef.encodings = [])).push(key);\n            } else {\n              if (selDef.type === 'interval') {\n                log.warn('Interval selections should be initialized using \"x\" and/or \"y\" keys.');\n                selDef.encodings = cfg.encodings;\n              } else {\n                (selDef.fields || (selDef.fields = [])).push(key);\n              }\n            }\n          }\n        }\n      } else {\n        selDef.encodings = cfg.encodings;\n        selDef.fields = cfg.fields;\n      }\n    } // TODO: find a possible channel mapping for these fields.\n\n\n    for (const field of selDef.fields || []) {\n      const p = {\n        type: 'E',\n        field\n      };\n      p.signals = Object.assign({}, signalName(p, 'data'));\n      proj.items.push(p);\n    }\n\n    for (const channel of selDef.encodings || []) {\n      const fieldDef = model.fieldDef(channel);\n\n      if (fieldDef) {\n        let field = fieldDef.field;\n\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel); // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n\n          const component = {\n            as: field,\n            field: fieldDef.field,\n            timeUnit: fieldDef.timeUnit\n          };\n          timeUnits[hash(component)] = component;\n        } // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n\n\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let type = 'E';\n\n          if (selCmpt.type === 'interval') {\n            const scaleType = model.getScaleComponent(channel).get('type');\n\n            if (hasContinuousDomain(scaleType)) {\n              type = 'R';\n            }\n          } else if (fieldDef.bin) {\n            type = 'R-RE';\n          }\n\n          const p = {\n            field,\n            channel,\n            type\n          };\n          p.signals = Object.assign(Object.assign({}, signalName(p, 'data')), signalName(p, 'visual'));\n          proj.items.push(parsed[field] = p);\n          proj.has[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    if (selDef.init) {\n      const parseInit = i => {\n        return proj.items.map(p => i[p.channel] !== undefined ? i[p.channel] : i[p.field]);\n      };\n\n      if (selDef.type === 'interval') {\n        selCmpt.init = parseInit(selDef.init);\n      } else {\n        const init = isArray(selDef.init) ? selDef.init : [selDef.init];\n        selCmpt.init = init.map(parseInit);\n      }\n    }\n\n    if (keys(timeUnits).length) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length ? allSignals : allSignals.concat({\n      name,\n      value: selCmpt.project.items.map(proj => {\n        const signals = proj.signals,\n              rest = __rest(proj, [\"signals\"]);\n\n        const p = duplicate(rest);\n        p.field = replacePathInField(p.field);\n        return p;\n      })\n    });\n  }\n};\nexport default project;","map":null,"metadata":{},"sourceType":"module"}