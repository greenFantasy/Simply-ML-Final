{"ast":null,"code":"import { selector as parseSelector } from 'vega-event-selector';\nimport { X, Y } from '../../../channel';\nimport { BRUSH as INTERVAL_BRUSH } from '../interval';\nimport scalesCompiler, { domain } from './scales';\nconst ANCHOR = '_translate_anchor';\nconst DELTA = '_translate_delta';\nconst translate = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.translate;\n  },\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.has(selCmpt);\n    const anchor = name + ANCHOR;\n    const _selCmpt$project$has = selCmpt.project.has,\n          x = _selCmpt$project$has.x,\n          y = _selCmpt$project$has.y;\n    let events = parseSelector(selCmpt.translate, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => (e.between[0].markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: anchor,\n      value: {},\n      on: [{\n        events: events.map(e => e.between[0]),\n        update: '{x: x(unit), y: y(unit)' + (x !== undefined ? ', extent_x: ' + (hasScales ? domain(model, X) : \"slice(\".concat(x.signals.visual, \")\")) : '') + (y !== undefined ? ', extent_y: ' + (hasScales ? domain(model, Y) : \"slice(\".concat(y.signals.visual, \")\")) : '') + '}'\n      }]\n    }, {\n      name: name + DELTA,\n      value: {},\n      on: [{\n        events: events,\n        update: \"{x: \".concat(anchor, \".x - x(unit), y: \").concat(anchor, \".y - y(unit)}\")\n      }]\n    });\n\n    if (x !== undefined) {\n      onDelta(model, selCmpt, x, 'width', signals);\n    }\n\n    if (y !== undefined) {\n      onDelta(model, selCmpt, y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\nexport default translate;\n\nfunction onDelta(model, selCmpt, proj, size, signals) {\n  const name = selCmpt.name;\n  const anchor = name + ANCHOR;\n  const delta = name + DELTA;\n  const channel = proj.channel;\n  const hasScales = scalesCompiler.has(selCmpt);\n  const signal = signals.filter(s => s.name === proj.signals[hasScales ? 'data' : 'visual'])[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const sign = hasScales && channel === X ? '-' : ''; // Invert delta when panning x-scales.\n\n  const extent = \"\".concat(anchor, \".extent_\").concat(channel);\n  const offset = \"\".concat(sign).concat(delta, \".\").concat(channel, \" / \") + (hasScales ? \"\".concat(sizeSg) : \"span(\".concat(extent, \")\"));\n  const panFn = !hasScales ? 'panLinear' : scaleType === 'log' ? 'panLog' : scaleType === 'pow' ? 'panPow' : 'panLinear';\n  const update = \"\".concat(panFn, \"(\").concat(extent, \", \").concat(offset) + (hasScales && scaleType === 'pow' ? \", \".concat(scaleCmpt.get('exponent') || 1) : '') + ')';\n  signal.on.push({\n    events: {\n      signal: delta\n    },\n    update: hasScales ? update : \"clampRange(\".concat(update, \", 0, \").concat(sizeSg, \")\")\n  });\n}","map":null,"metadata":{},"sourceType":"module"}