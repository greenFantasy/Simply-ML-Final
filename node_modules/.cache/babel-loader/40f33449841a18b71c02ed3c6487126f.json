{"ast":null,"code":"import { isScaleChannel } from '../../channel';\nimport { vgField as fieldRef } from '../../channeldef';\nimport { isPathMark } from '../../mark';\nimport { hasContinuousDomain } from '../../scale';\nimport { hash, keys } from '../../util';\nimport { getMarkPropOrConfig } from '../common';\nimport { DataFlowNode } from './dataflow';\nexport class FilterInvalidNode extends DataFlowNode {\n  constructor(parent, filter) {\n    super(parent);\n    this.filter = filter;\n  }\n\n  clone() {\n    return new FilterInvalidNode(null, Object.assign({}, this.filter));\n  }\n\n  static make(parent, model) {\n    const config = model.config,\n          mark = model.mark,\n          markDef = model.markDef;\n    const invalid = getMarkPropOrConfig('invalid', markDef, config);\n\n    if (invalid !== 'filter') {\n      return null;\n    }\n\n    const filter = model.reduceFieldDef((aggregator, fieldDef, channel) => {\n      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n\n      if (scaleComponent) {\n        const scaleType = scaleComponent.get('type'); // While discrete domain scales can handle invalid values, continuous scales can't.\n        // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n        // (For path marks, we will use \"defined\" property and skip these values instead.)\n\n        if (hasContinuousDomain(scaleType) && !fieldDef.aggregate && !isPathMark(mark)) {\n          aggregator[fieldDef.field] = fieldDef; // we know that the fieldDef is a typed field def\n        }\n      }\n\n      return aggregator;\n    }, {});\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  dependentFields() {\n    return new Set(keys(this.filter));\n  }\n\n  producedFields() {\n    return new Set(); // filter does not produce any new fields\n  }\n\n  hash() {\n    return \"FilterInvalid \".concat(hash(this.filter));\n  }\n  /**\n   * Create the VgTransforms for each of the filtered fields.\n   */\n\n\n  assemble() {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {\n        expr: 'datum'\n      });\n\n      if (fieldDef !== null) {\n        if (fieldDef.type === 'temporal') {\n          vegaFilters.push(\"(isDate(\".concat(ref, \") || (isValid(\").concat(ref, \") && isFinite(+\").concat(ref, \")))\"));\n        } else if (fieldDef.type === 'quantitative') {\n          vegaFilters.push(\"isValid(\".concat(ref, \")\"));\n          vegaFilters.push(\"isFinite(+\".concat(ref, \")\"));\n        } else {// should never get here\n        }\n      }\n\n      return vegaFilters;\n    }, []);\n    return filters.length > 0 ? {\n      type: 'filter',\n      expr: filters.join(' && ')\n    } : null;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}