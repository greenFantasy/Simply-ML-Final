{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst preact_1 = require(\"preact\");\n\nconst glamor_1 = require(\"glamor\");\n\nconst glamor_tachyons_1 = require(\"glamor-tachyons\");\n\nconst surface_1 = require(\"./surface\");\n\nconst tabs_1 = require(\"./tabs\");\n/**\n * The Visor is a component that displays and manages 'Tabs' and 'Surfaces'.\n *\n * It is meant to exist as a singleton component on a given page and is thus\n * accessed by a visor() function that exposes a single instance of this\n * component via an imperative API (i.e. its implementation as a (p)react\n * component is an internal implementation detail.\n *\n * Following that, and somewhat unlike a typical react component, it does allow\n * for imperative calls to that instance to modify internal state. Any state\n * that needs to be serialized or persisted should be lifted to props.\n */\n\n\nclass VisorComponent extends preact_1.Component {\n  /**\n   * Helper function to render the component to the DOM.\n   *\n   * Note that although the visor has a parent element, it rendered via absolute\n   * positioning and is thus taken out of regular document flow.\n   *\n   * @param parent A DOM element\n   * @param replaceNode The element that re-rendering this component would\n   *                    replace. Usually null initially and will be returned by\n   *                    this function after the first render.\n   * @param props Initial visor props\n   */\n  static render(parent, replaceNode, props) {\n    return preact_1.render(preact_1.h(VisorComponent, Object.assign({}, props)), parent, replaceNode);\n  }\n\n  constructor(props) {\n    super(props);\n    this.surfaces = new Map();\n    const startOpen = props.startOpen == null ? true : props.startOpen;\n    this.state = {\n      isOpen: startOpen,\n      isFullscreen: false,\n      activeTab: null,\n      tabs: new Set()\n    };\n    this.keyHandler = this.keyHandler.bind(this);\n  } // These public methods are exposed via an imperative interface\n\n\n  close() {\n    this.setState({\n      isOpen: false\n    });\n  }\n\n  open() {\n    this.setState({\n      isOpen: true\n    });\n  }\n\n  toggle() {\n    this.setState({\n      isOpen: !this.state.isOpen\n    });\n  }\n\n  toggleFullScreen() {\n    this.setState({\n      isFullscreen: !this.state.isFullscreen\n    });\n  }\n\n  isOpen() {\n    return this.state.isOpen;\n  }\n\n  isFullscreen() {\n    return this.state.isFullscreen;\n  }\n\n  getSurface(label, tab) {\n    const surfaceId = this.surfaceId(label, tab);\n    let surface;\n\n    if (this.surfaces.has(surfaceId)) {\n      surface = this.surfaces.get(surfaceId);\n    } else {\n      throw Error(\"Surface not found with id: \".concat(surfaceId));\n    }\n\n    return {\n      container: surface.container,\n      label: surface.label,\n      drawArea: surface.drawArea\n    };\n  }\n\n  bindKeys() {\n    document.addEventListener('keydown', this.keyHandler, false);\n  }\n\n  unbindKeys() {\n    document.removeEventListener('keydown', this.keyHandler);\n  }\n\n  surfaceId(label, tab) {\n    return label + tab;\n  }\n\n  setTabs(surfaceList) {\n    // Check if we have new tabs\n    const nextTabs = surfaceList.map(s => s.tab);\n    const tabs = this.state.tabs;\n    let newActiveTab;\n\n    for (const tab of nextTabs) {\n      if (!tabs.has(tab)) {\n        tabs.add(tab);\n        newActiveTab = tab;\n      }\n    }\n\n    if (newActiveTab != null) {\n      this.setState({\n        tabs,\n        activeTab: newActiveTab\n      });\n    }\n  }\n\n  getTabs() {\n    return this.state.tabs;\n  } // Event Handlers\n\n\n  registerSurface(name, tab, surface) {\n    const surfaceId = this.surfaceId(name, tab);\n    this.surfaces.set(surfaceId, surface);\n  }\n\n  keyHandler(event) {\n    const BACKTICK_KEY = 192;\n\n    if (event.keyCode === BACKTICK_KEY) {\n      if (event.shiftKey) {\n        this.toggleFullScreen();\n      } else {\n        this.toggle();\n      }\n    }\n  }\n\n  setActiveTab(tab) {\n    this.setState({\n      activeTab: tab\n    });\n  } // Lifecycle Methods\n\n\n  componentDidMount() {\n    this.bindKeys();\n  }\n\n  componentWillMount() {\n    this.setTabs(this.props.surfaceList);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setTabs(nextProps.surfaceList);\n  }\n\n  render() {\n    const _this$state = this.state,\n          isOpen = _this$state.isOpen,\n          isFullscreen = _this$state.isFullscreen,\n          activeTab = _this$state.activeTab;\n    const surfaceList = this.props.surfaceList;\n    const tabNames = Array.from(this.getTabs().values());\n    const SMALL_WIDTH = '550px';\n    const LARGE_WIDTH = '90vw';\n    const width = isFullscreen ? LARGE_WIDTH : SMALL_WIDTH;\n    const defaultStyles = glamor_1.css({\n      width,\n      height: '100%',\n      backgroundColor: '#fafafa',\n      boxSizing: 'border-box',\n      padding: '10px',\n      position: 'fixed',\n      top: '0px',\n      // tslint:disable-next-line\n      transition: \"right 0.5s cubic-bezier(0.645, 0.045, 0.355, 1), width 0.5s cubic-bezier(0.645, 0.045, 0.355, 1)\",\n      boxShadow: '0 2px 5px rgba(0, 0, 0, 0.12), 0 2px 5px rgba(0, 0, 0, 0.24)',\n      overflow: 'auto',\n      fontFamily: 'sans-serif',\n      fontSize: '14px',\n      zIndex: 1000\n    });\n    const openStyle = glamor_1.css({\n      right: '0'\n    });\n    const closedStyle = glamor_1.css({\n      right: \"calc(-\".concat(width, \" - 10px)\")\n    });\n    const position = isOpen ? openStyle : closedStyle; // TODO. Add flex wrapping for surfaces\n\n    const surfacesContainerStyle = glamor_1.css({});\n    return preact_1.h(\"div\", {\n      className: \"\".concat(defaultStyles, \" \").concat(position, \" visor\"),\n      \"data-isopen\": isOpen,\n      \"data-isfullscreen\": isFullscreen\n    }, preact_1.h(VisorControls, {\n      fullScreenHandler: this.toggleFullScreen.bind(this),\n      closeHandler: this.close.bind(this),\n      isFullScreen: isFullscreen\n    }), preact_1.h(tabs_1.Tabs, {\n      tabNames: tabNames,\n      activeTab: activeTab,\n      handleClick: this.setActiveTab.bind(this)\n    }), preact_1.h(\"div\", {\n      className: \"\".concat(surfacesContainerStyle, \" visor-surfaces\")\n    }, surfaceList.map(surfaceInfo => preact_1.h(surface_1.SurfaceComponent, {\n      key: surfaceInfo.name + surfaceInfo.tab,\n      name: surfaceInfo.name,\n      tab: surfaceInfo.tab,\n      styles: surfaceInfo.styles,\n      registerSurface: this.registerSurface.bind(this),\n      visible: activeTab === surfaceInfo.tab\n    }))));\n  }\n\n}\n\nexports.VisorComponent = VisorComponent;\n\nfunction VisorControls(props) {\n  const isFullScreen = props.isFullScreen,\n        fullScreenHandler = props.fullScreenHandler,\n        closeHandler = props.closeHandler;\n  const toolBarStyle = glamor_1.css({\n    display: 'flex',\n    backgroundColor: 'white',\n    border: '1px solid white',\n    padding: '6px',\n    paddingTop: '10px',\n    marginBottom: '10px',\n    borderRadius: '6px',\n    marginTop: '-16px'\n  });\n  const controlsButtonClass = glamor_1.css(Object.assign({}, glamor_tachyons_1.tachyons('f6 link br2 ph3 pv2 near-black')));\n  const floatRight = glamor_1.css({\n    marginLeft: 'auto'\n  });\n  return preact_1.h(\"div\", {\n    className: \"\".concat(toolBarStyle, \" visor-controls\")\n  }, preact_1.h(\"button\", {\n    className: \"\".concat(controlsButtonClass),\n    onClick: fullScreenHandler\n  }, isFullScreen ? 'Minimize' : 'Maximize'), preact_1.h(\"button\", {\n    className: \"\".concat(controlsButtonClass, \" \").concat(floatRight),\n    onClick: closeHandler\n  }, \"Hide\"));\n}","map":null,"metadata":{},"sourceType":"script"}