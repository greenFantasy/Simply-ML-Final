{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _slicedToArray = require(\"/Users/rajatmittal/Documents/SMLTest/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tfjs_1 = require(\"@tensorflow/tfjs\");\n\nconst utils_1 = require(\"./utils\");\n/**\n * Returns summary statistics for an array of numbers\n *\n * @param input\n */\n\n\nfunction arrayStats(input) {\n  if (!Array.isArray(input)) {\n    throw new Error('input must be an array');\n  }\n\n  if (input.length === 0) {\n    return {\n      numVals: 0,\n      numNans: 0,\n      numZeros: 0,\n      max: undefined,\n      min: undefined\n    };\n  }\n\n  const numVals = input.length;\n  let max = -Infinity;\n  let min = Infinity;\n  let numZeros = 0;\n  let numNans = 0;\n  let numInfs = 0;\n\n  for (let i = 0; i < numVals; i++) {\n    const curr = input[i];\n\n    if (curr > max) {\n      max = curr;\n    }\n\n    if (curr < min) {\n      min = curr;\n    }\n\n    if (curr === 0) {\n      numZeros += 1;\n    }\n\n    if (isNaN(curr)) {\n      numNans += 1;\n    } else if (!isFinite(curr)) {\n      // Make sure NaNs are not double counted as Infs\n      numInfs += 1;\n    }\n  }\n\n  const result = {\n    numVals,\n    numZeros,\n    numNans,\n    max,\n    min,\n    numInfs\n  }; // Handle all NaN input\n\n  if (result.max === -Infinity) {\n    result.max = NaN;\n  }\n\n  if (result.min === Infinity) {\n    result.min = NaN;\n  }\n\n  return result;\n}\n\nexports.arrayStats = arrayStats;\n/**\n * Returns summary statistics for a numeric tensor. *\n *\n * @param input\n */\n\nfunction tensorStats(input) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // TODO. Benchmark this and consider having one of the *stats functions\n    // delegate to the other.\n    const _tfjs_1$tidy = tfjs_1.tidy(() => {\n      const zero = tfjs_1.scalar(0, input.dtype);\n      const min = input.min();\n      const max = input.max();\n      const numZeros = input.equal(zero).sum();\n      return [min, max, numZeros];\n    }),\n          _tfjs_1$tidy2 = _slicedToArray(_tfjs_1$tidy, 3),\n          min = _tfjs_1$tidy2[0],\n          max = _tfjs_1$tidy2[1],\n          numZeros = _tfjs_1$tidy2[2];\n\n    return Promise.all([input.data(), min.data(), max.data(), numZeros.data()]).then(([tensorVal, minVal, maxVal, numZerosVal]) => {\n      // We currently need to count NaNs on CPU.\n      const numVals = tensorVal.length;\n      let numNans = 0;\n      let numInfs = 0;\n\n      for (let i = 0; i < numVals; i++) {\n        const curr = tensorVal[i];\n\n        if (isNaN(curr)) {\n          numNans += 1;\n        } else if (!isFinite(curr)) {\n          // Make sure NaNs are not double counted as Infs\n          numInfs += 1;\n        }\n      }\n\n      let trueMin = minVal[0];\n      let trueMax = maxVal[0];\n\n      if (numNans === numVals) {\n        // on gpu the min and max won't be accurate if all values are NaN\n        trueMin = NaN;\n        trueMax = NaN;\n      }\n\n      const stats = {\n        numVals,\n        numZeros: numZerosVal[0],\n        numNans,\n        min: trueMin,\n        max: trueMax,\n        numInfs\n      };\n      return stats;\n    });\n  });\n}\n\nexports.tensorStats = tensorStats;\n/**\n * Computes a confusion matrix from predictions and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([1, 2, 4]);\n * const predictions = tf.tensor1d([2, 2, 4]);\n * const result = await tfvis.metrics.confusionMatrix(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n * @param weights 1d tensor that is the same size as predictions.\n *  If weights is passed in then each prediction contributes its corresponding\n *  weight to the total value of the confusion matrix cell.\n *\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction confusionMatrix(labels, predictions, numClasses, weights) {\n  return __awaiter(this, void 0, void 0, function* () {\n    utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n    utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n    utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n\n    if (weights != null) {\n      utils_1.assert(weights.size === predictions.size, 'labels and predictions must be the same length');\n    } // Cast to int in case the caller didn't\n\n\n    const labelsInt = labels.cast('int32');\n    const predictionsInt = predictions.cast('int32');\n\n    if (numClasses == null) {\n      numClasses = tfjs_1.tidy(() => {\n        const max = tfjs_1.maximum(labelsInt.max(), predictionsInt.max()).cast('int32');\n        return max.dataSync()[0] + 1;\n      });\n    }\n\n    let weightsPromise = Promise.resolve(null);\n\n    if (weights != null) {\n      weightsPromise = weights.data();\n    }\n\n    return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise]).then(([labelsArray, predsArray, weightsArray]) => {\n      const result = Array(numClasses).fill(0); // Initialize the matrix\n\n      for (let i = 0; i < numClasses; i++) {\n        result[i] = Array(numClasses).fill(0);\n      }\n\n      for (let i = 0; i < labelsArray.length; i++) {\n        const label = labelsArray[i];\n        const pred = predsArray[i];\n\n        if (weightsArray != null) {\n          result[label][pred] += weightsArray[i];\n        } else {\n          result[label][pred] += 1;\n        }\n      }\n\n      return result;\n    });\n  });\n}\n\nexports.confusionMatrix = confusionMatrix;\n/**\n * Computes how often predictions matches labels\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.accuracy(labels, predictions);\n * console.log(result)\n * ```\n *\n * @param labels tensor of true values\n * @param predictions tensor of predicted values\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction accuracy(labels, predictions) {\n  return __awaiter(this, void 0, void 0, function* () {\n    utils_1.assertShapesMatch(labels.shape, predictions.shape, 'Error computing accuracy.');\n    const eq = labels.equal(predictions);\n    const mean = eq.mean();\n    const acc = (yield mean.data())[0];\n    tfjs_1.dispose([eq, mean]);\n    return acc;\n  });\n}\n\nexports.accuracy = accuracy;\n/**\n * Computes per class accuracy between prediction and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.perClassAccuracy(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * Returns an array of objects that each have an an `accuracy` and a `count`\n * property for each class.\n *\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n */\n\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\n\nfunction perClassAccuracy(labels, predictions, numClasses) {\n  return __awaiter(this, void 0, void 0, function* () {\n    utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n    utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n    utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n\n    if (numClasses == null) {\n      numClasses = tfjs_1.tidy(() => {\n        return tfjs_1.maximum(labels.max(), predictions.max()).dataSync()[0] + 1;\n      });\n    }\n\n    return Promise.all([labels.data(), predictions.data()]).then(([labelsArray, predsArray]) => {\n      // Per class total counts\n      const counts = Array(numClasses).fill(0); // Per class accuracy\n\n      const accuracy = Array(numClasses).fill(0);\n\n      for (let i = 0; i < labelsArray.length; i++) {\n        const label = labelsArray[i];\n        const pred = predsArray[i];\n        counts[label] += 1;\n\n        if (label === pred) {\n          accuracy[label] += 1;\n        }\n      }\n\n      const results = [];\n\n      for (let i = 0; i < counts.length; i++) {\n        results.push({\n          count: counts[i],\n          accuracy: counts[i] === 0 ? 0 : accuracy[i] / counts[i]\n        });\n      }\n\n      return results;\n    });\n  });\n}\n\nexports.perClassAccuracy = perClassAccuracy;","map":null,"metadata":{},"sourceType":"script"}