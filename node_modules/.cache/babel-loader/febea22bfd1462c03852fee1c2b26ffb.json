{"ast":null,"code":"import { GEOPOSITION_CHANNELS, NONPOSITION_SCALE_CHANNELS, SCALE_CHANNELS, supportLegend, X, Y } from '../channel';\nimport { getTypedFieldDef, hasConditionalFieldDef, isFieldDef } from '../channeldef';\nimport { isGraticuleGenerator } from '../data';\nimport * as vlEncoding from '../encoding';\nimport { normalizeEncoding } from '../encoding';\nimport { GEOSHAPE, isMarkDef } from '../mark';\nimport { stack } from '../stack';\nimport { assembleAxisSignals } from './axis/assemble';\nimport { parseUnitAxes } from './axis/parse';\nimport { parseData } from './data/parse';\nimport { assembleLayoutSignals } from './layoutsize/assemble';\nimport { initLayoutSize } from './layoutsize/init';\nimport { parseUnitLayoutSize } from './layoutsize/parse';\nimport { normalizeMarkDef } from './mark/init';\nimport { parseMarkGroups } from './mark/mark';\nimport { isLayerModel, ModelWithField } from './model';\nimport { replaceRepeaterInEncoding } from './repeater';\nimport { assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals } from './selection/assemble';\nimport { parseUnitSelection } from './selection/parse';\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\n\nexport class UnitModel extends ModelWithField {\n  constructor(spec, parent, parentGivenName, parentGivenSize = {}, repeater, config) {\n    super(spec, 'unit', parent, parentGivenName, config, repeater, undefined, spec.view);\n    this.specifiedScales = {};\n    this.specifiedAxes = {};\n    this.specifiedLegends = {};\n    this.specifiedProjection = {};\n    this.selection = {};\n    this.children = [];\n    const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n    const encodingWithRepeaterReplaced = replaceRepeaterInEncoding(spec.encoding || {}, repeater);\n    this.markDef = normalizeMarkDef(spec.mark, encodingWithRepeaterReplaced, config, {\n      graticule: spec.data && isGraticuleGenerator(spec.data)\n    });\n    const encoding = this.encoding = normalizeEncoding(encodingWithRepeaterReplaced, this.markDef);\n    this.size = initLayoutSize({\n      encoding,\n      size: Object.assign(Object.assign(Object.assign({}, parentGivenSize), spec.width ? {\n        width: spec.width\n      } : {}), spec.height ? {\n        height: spec.height\n      } : {})\n    }); // calculate stack properties\n\n    this.stack = stack(mark, encoding);\n    this.specifiedScales = this.initScales(mark, encoding);\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegend(encoding);\n    this.specifiedProjection = spec.projection; // Selections will be initialized upon parse.\n\n    this.selection = spec.selection;\n  }\n\n  get hasProjection() {\n    const encoding = this.encoding;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n  /**\n   * Return specified Vega-lite scale domain for a particular channel\n   * @param channel\n   */\n\n\n  scaleDomain(channel) {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  axis(channel) {\n    return this.specifiedAxes[channel];\n  }\n\n  legend(channel) {\n    return this.specifiedLegends[channel];\n  }\n\n  initScales(mark, encoding) {\n    return SCALE_CHANNELS.reduce((scales, channel) => {\n      let fieldDef;\n      let specifiedScale;\n      const channelDef = encoding[channel];\n\n      if (isFieldDef(channelDef)) {\n        fieldDef = channelDef;\n        specifiedScale = channelDef.scale;\n      } else if (hasConditionalFieldDef(channelDef)) {\n        // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n        fieldDef = channelDef.condition;\n        specifiedScale = channelDef.condition['scale'];\n      }\n\n      if (fieldDef) {\n        scales[channel] = specifiedScale || {};\n      }\n\n      return scales;\n    }, {});\n  }\n\n  initAxes(encoding) {\n    return [X, Y].reduce((_axis, channel) => {\n      // Position Axis\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n\n      if (isFieldDef(channelDef) || channel === X && isFieldDef(encoding.x2) || channel === Y && isFieldDef(encoding.y2)) {\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        if (axisSpec !== null) {\n          _axis[channel] = Object.assign({}, axisSpec);\n        }\n      }\n\n      return _axis;\n    }, {});\n  }\n\n  initLegend(encoding) {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const channelDef = encoding[channel];\n\n      if (channelDef) {\n        const legend = isFieldDef(channelDef) ? channelDef.legend : hasConditionalFieldDef(channelDef) // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n        ? channelDef.condition['legend'] : null;\n\n        if (legend !== null && legend !== false && supportLegend(channel)) {\n          _legend[channel] = Object.assign({}, legend);\n        }\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  parseData() {\n    this.component.data = parseData(this);\n  }\n\n  parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  parseSelections() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  parseMarkGroup() {\n    this.component.mark = parseMarkGroups(this);\n  }\n\n  parseAxesAndHeaders() {\n    this.component.axes = parseUnitAxes(this);\n  }\n\n  assembleSelectionTopLevelSignals(signals) {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  assembleSignals() {\n    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];\n  }\n\n  assembleSelectionData(data) {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  assembleLayout() {\n    return null;\n  }\n\n  assembleLayoutSignals() {\n    return assembleLayoutSignals(this);\n  }\n\n  assembleMarks() {\n    let marks = this.component.mark || []; // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  getMapping() {\n    return this.encoding;\n  }\n\n  get mark() {\n    return this.markDef.type;\n  }\n\n  channelHasField(channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  fieldDef(channel) {\n    const channelDef = this.encoding[channel];\n    return getTypedFieldDef(channelDef);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}