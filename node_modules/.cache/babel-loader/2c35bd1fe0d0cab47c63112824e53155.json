{"ast":null,"code":"import { isArray, isString } from 'vega-util';\nimport { getTypedFieldDef, isFieldDef, vgField } from '../../channeldef';\nimport { duplicate, getFirstDefined, hash } from '../../util';\nimport { sortParams } from '../common';\nimport { DataFlowNode } from './dataflow';\n\nfunction getStackByFields(model) {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const fieldDef = by.fieldDef;\n\n    const _field = vgField(fieldDef);\n\n    if (_field) {\n      fields.push(_field);\n    }\n\n    return fields;\n  }, []);\n}\n\nfunction isValidAsArray(as) {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends DataFlowNode {\n  constructor(parent, stack) {\n    super(parent);\n    this._stack = stack;\n  }\n\n  clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  static makeFromTransform(parent, stackTransform) {\n    const stack = stackTransform.stack,\n          groupby = stackTransform.groupby,\n          as = stackTransform.as,\n          _stackTransform$offse = stackTransform.offset,\n          offset = _stackTransform$offse === void 0 ? 'zero' : _stackTransform$offse;\n    const sortFields = [];\n    const sortOrder = [];\n\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n\n    const sort = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs;\n\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, as + '_end'];\n    } else {\n      normalizedAs = [stackTransform.stack + '_start', stackTransform.stack + '_end'];\n    }\n\n    return new StackNode(parent, {\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  static makeFromEncoding(parent, model) {\n    const stackProperties = model.stack;\n    const encoding = model.encoding;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    let dimensionFieldDef;\n\n    if (stackProperties.groupbyChannel) {\n      const cDef = encoding[stackProperties.groupbyChannel];\n      dimensionFieldDef = getTypedFieldDef(cDef); // Fair to cast as groupByChannel is always either x or y\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n    let sort;\n\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        s.field.push(field);\n        s.order.push('descending');\n        return s;\n      }, {\n        field: [],\n        order: []\n      });\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDef,\n      stackField: model.vgField(stackProperties.fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset: stackProperties.offset,\n      impute: stackProperties.impute,\n      as: [model.vgField(stackProperties.fieldChannel, {\n        suffix: 'start',\n        forAs: true\n      }), model.vgField(stackProperties.fieldChannel, {\n        suffix: 'end',\n        forAs: true\n      })]\n    });\n  }\n\n  get stack() {\n    return this._stack;\n  }\n\n  addDimensions(fields) {\n    this._stack.facetby.push(...fields);\n  }\n\n  dependentFields() {\n    const out = new Set();\n    out.add(this._stack.stackField);\n    this.getGroupbyFields().forEach(f => out.add(f));\n\n    this._stack.facetby.forEach(f => out.add(f));\n\n    this._stack.sort.field.forEach(f => out.add(f));\n\n    return out;\n  }\n\n  producedFields() {\n    return new Set(this._stack.as);\n  }\n\n  hash() {\n    return \"Stack \".concat(hash(this._stack));\n  }\n\n  getGroupbyFields() {\n    const _this$_stack = this._stack,\n          dimensionFieldDef = _this$_stack.dimensionFieldDef,\n          impute = _this$_stack.impute,\n          groupby = _this$_stack.groupby;\n\n    if (dimensionFieldDef) {\n      if (dimensionFieldDef.bin) {\n        if (impute) {\n          // For binned group by field with impute, we calculate bin_mid\n          // as we cannot impute two fields simultaneously\n          return [vgField(dimensionFieldDef, {\n            binSuffix: 'mid'\n          })];\n        }\n\n        return [// For binned group by field without impute, we need both bin (start) and bin_end\n        vgField(dimensionFieldDef, {}), vgField(dimensionFieldDef, {\n          binSuffix: 'end'\n        })];\n      }\n\n      return [vgField(dimensionFieldDef)];\n    }\n\n    return groupby || [];\n  }\n\n  assemble() {\n    const transform = [];\n    const _this$_stack2 = this._stack,\n          facetby = _this$_stack2.facetby,\n          dimensionFieldDef = _this$_stack2.dimensionFieldDef,\n          field = _this$_stack2.stackField,\n          stackby = _this$_stack2.stackby,\n          sort = _this$_stack2.sort,\n          offset = _this$_stack2.offset,\n          impute = _this$_stack2.impute,\n          as = _this$_stack2.as; // Impute\n\n    if (impute && dimensionFieldDef) {\n      const _dimensionFieldDef$ba = dimensionFieldDef.band,\n            band = _dimensionFieldDef$ba === void 0 ? 0.5 : _dimensionFieldDef$ba,\n            bin = dimensionFieldDef.bin;\n\n      if (bin) {\n        // As we can only impute one field at a time, we need to calculate\n        // mid point for a binned field\n        transform.push({\n          type: 'formula',\n          expr: \"\".concat(band, \"*\") + vgField(dimensionFieldDef, {\n            expr: 'datum'\n          }) + \"+\".concat(1 - band, \"*\") + vgField(dimensionFieldDef, {\n            expr: 'datum',\n            binSuffix: 'end'\n          }),\n          as: vgField(dimensionFieldDef, {\n            binSuffix: 'mid',\n            forAs: true\n          })\n        });\n      }\n\n      transform.push({\n        type: 'impute',\n        field,\n        groupby: [...stackby, ...facetby],\n        key: vgField(dimensionFieldDef, {\n          binSuffix: 'mid'\n        }),\n        method: 'value',\n        value: 0\n      });\n    } // Stack\n\n\n    transform.push({\n      type: 'stack',\n      groupby: [...this.getGroupbyFields(), ...facetby],\n      field,\n      sort,\n      as,\n      offset\n    });\n    return transform;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}