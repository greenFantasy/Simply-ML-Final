{"ast":null,"code":"import { getSecondaryRangeChannel } from '../../channel';\nimport { hasBand, vgField } from '../../channeldef';\nimport { fieldExpr } from '../../timeunit';\nimport { duplicate, hash, keys, vals } from '../../util';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\nexport class TimeUnitNode extends DataFlowNode {\n  constructor(parent, formula) {\n    super(parent);\n    this.formula = formula;\n  }\n\n  clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {\n      const timeUnit = fieldDef.timeUnit,\n            field = fieldDef.field;\n      const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : undefined;\n      const band = isUnitModel(model) && hasBand(channel, fieldDef, channelDef2, model.markDef, model.config);\n\n      if (timeUnit) {\n        const as = vgField(fieldDef, {\n          forAs: true\n        });\n        timeUnitComponent[hash({\n          as,\n          timeUnit,\n          field\n        })] = Object.assign({\n          as,\n          timeUnit,\n          field\n        }, band ? {\n          band: true\n        } : {});\n      }\n\n      return timeUnitComponent;\n    }, {});\n\n    if (keys(formula).length === 0) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  static makeFromTransform(parent, t) {\n    const component = Object.assign({}, t);\n    return new TimeUnitNode(parent, {\n      [hash(component)]: component\n    });\n  }\n  /**\n   * Merge together TimeUnitNodes assigning the children of `other` to `this`\n   * and removing `other`.\n   */\n\n\n  merge(other) {\n    this.formula = Object.assign({}, this.formula); // if the same hash happen twice, merge \"band\"\n\n    for (const key in other.formula) {\n      if (!this.formula[key] || other.formula[key].band) {\n        // copy if it's not a duplicate or if we need to include copy band over\n        this.formula[key] = other.formula[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  producedFields() {\n    return new Set(vals(this.formula).map(f => f.as));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.formula).map(f => f.field));\n  }\n\n  hash() {\n    return \"TimeUnit \".concat(hash(this.formula));\n  }\n\n  assemble() {\n    const transforms = [];\n\n    for (const f of vals(this.formula)) {\n      const timeUnit = f.timeUnit,\n            field = f.field,\n            as = f.as,\n            band = f.band;\n      transforms.push({\n        type: 'formula',\n        as,\n        expr: fieldExpr(timeUnit, field)\n      });\n\n      if (band) {\n        transforms.push({\n          type: 'formula',\n          as: as + '_end',\n          expr: fieldExpr(timeUnit, field, {\n            end: true\n          })\n        });\n      }\n    }\n\n    return transforms;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}