{"ast":null,"code":"import { ingest, Transform } from 'vega-dataflow';\nimport { inherits } from 'vega-util';\nimport { extent } from 'd3-array';\nimport { contours, contourDensity } from 'd3-contour';\nvar CONTOUR_PARAMS = ['size', 'smooth'];\nvar DENSITY_PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\n\nexport default function Contour(params) {\n  Transform.call(this, null, params);\n}\nContour.Definition = {\n  \"type\": \"Contour\",\n  \"metadata\": {\n    \"generates\": true\n  },\n  \"params\": [{\n    \"name\": \"size\",\n    \"type\": \"number\",\n    \"array\": true,\n    \"length\": 2,\n    \"required\": true\n  }, {\n    \"name\": \"values\",\n    \"type\": \"number\",\n    \"array\": true\n  }, {\n    \"name\": \"x\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"y\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"weight\",\n    \"type\": \"field\"\n  }, {\n    \"name\": \"cellSize\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"bandwidth\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"count\",\n    \"type\": \"number\"\n  }, {\n    \"name\": \"smooth\",\n    \"type\": \"boolean\"\n  }, {\n    \"name\": \"nice\",\n    \"type\": \"boolean\",\n    \"default\": false\n  }, {\n    \"name\": \"thresholds\",\n    \"type\": \"number\",\n    \"array\": true\n  }]\n};\nvar prototype = inherits(Contour, Transform);\n\nprototype.transform = function (_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      count = _.count || 10,\n      contour,\n      params,\n      values;\n\n  if (_.values) {\n    contour = contours();\n    params = CONTOUR_PARAMS;\n    values = _.values;\n  } else {\n    contour = contourDensity();\n    params = DENSITY_PARAMS;\n    values = pulse.materialize(pulse.SOURCE).source;\n  } // set threshold parameter\n\n\n  contour.thresholds(_.thresholds || (_.nice ? count : quantize(count))); // set all other parameters\n\n  params.forEach(function (param) {\n    if (_[param] != null) contour[param](_[param]);\n  });\n  if (this.value) out.rem = this.value;\n  values = values && values.length ? contour(values).map(ingest) : [];\n  this.value = out.source = out.add = values;\n  return out;\n};\n\nfunction quantize(k) {\n  return function (values) {\n    var ex = extent(values),\n        x0 = ex[0],\n        dx = ex[1] - x0,\n        t = [],\n        i = 1;\n\n    for (; i <= k; ++i) t.push(x0 + dx * i / (k + 1));\n\n    return t;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}