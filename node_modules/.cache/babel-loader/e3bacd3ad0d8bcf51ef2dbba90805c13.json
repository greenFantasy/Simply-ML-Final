{"ast":null,"code":"import { hasOwnProperty } from 'vega-util';\nimport invertRange from './scales/invertRange';\nimport invertRangeExtent from './scales/invertRangeExtent';\nimport { Identity, Linear, Log, Pow, Sqrt, Symlog, Time, UTC, Sequential, Diverging, Quantile, Quantize, Threshold, BinOrdinal, Ordinal, Band, Point } from './scales/types';\nimport { band as scaleBand, point as scalePoint } from './scales/scaleBand';\nimport { scaleBinOrdinal } from './scales/scaleBinOrdinal';\nimport * as $ from 'd3-scale';\n/**\n * Augment scales with their type and needed inverse methods.\n */\n\nfunction create(type, constructor) {\n  return function scale() {\n    var s = constructor();\n\n    if (!s.invertRange) {\n      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;\n    }\n\n    s.type = type;\n    return s;\n  };\n}\n\nexport default function scale(type, scale) {\n  if (arguments.length > 1) {\n    scales[type] = create(type, scale);\n    return this;\n  } else {\n    return hasOwnProperty(scales, type) ? scales[type] : undefined;\n  }\n}\nvar scales = {\n  // identity scale\n  [Identity]: $.scaleIdentity,\n  // continuous scales\n  [Linear]: $.scaleLinear,\n  [Log]: $.scaleLog,\n  [Pow]: $.scalePow,\n  [Sqrt]: $.scaleSqrt,\n  [Symlog]: $.scaleSymlog,\n  [Time]: $.scaleTime,\n  [UTC]: $.scaleUtc,\n  // sequential scales\n  [Sequential]: $.scaleSequential,\n  // backwards compat\n  [Sequential + '-' + Linear]: $.scaleSequential,\n  [Sequential + '-' + Log]: $.scaleSequentialLog,\n  [Sequential + '-' + Pow]: $.scaleSequentialPow,\n  [Sequential + '-' + Sqrt]: $.scaleSequentialSqrt,\n  [Sequential + '-' + Symlog]: $.scaleSequentialSymlog,\n  // diverging scales\n  [Diverging + '-' + Linear]: $.scaleDiverging,\n  [Diverging + '-' + Log]: $.scaleDivergingLog,\n  [Diverging + '-' + Pow]: $.scaleDivergingPow,\n  [Diverging + '-' + Sqrt]: $.scaleDivergingSqrt,\n  [Diverging + '-' + Symlog]: $.scaleDivergingSymlog,\n  // discretizing scales\n  [Quantile]: $.scaleQuantile,\n  [Quantize]: $.scaleQuantize,\n  [Threshold]: $.scaleThreshold,\n  // discrete scales\n  [BinOrdinal]: scaleBinOrdinal,\n  [Ordinal]: $.scaleOrdinal,\n  [Band]: scaleBand,\n  [Point]: scalePoint\n};\n\nfor (var key in scales) {\n  scale(key, scales[key]);\n}","map":null,"metadata":{},"sourceType":"module"}