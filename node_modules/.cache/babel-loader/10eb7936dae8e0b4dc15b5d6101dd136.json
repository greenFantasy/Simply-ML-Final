{"ast":null,"code":"import { isArray } from 'vega-util';\nimport { isBinning } from '../../bin';\nimport { COLUMN, FACET_CHANNELS, ROW } from '../../channel';\nimport { vgField } from '../../channeldef';\nimport * as log from '../../log';\nimport { hasDiscreteDomain } from '../../scale';\nimport { DEFAULT_SORT_OP, isSortField } from '../../sort';\nimport { hash } from '../../util';\nimport { isVgRangeStep } from '../../vega.schema';\nimport { HEADER_CHANNELS, HEADER_TYPES } from '../header/component';\nimport { assembleDomain, getFieldFromDomain } from '../scale/domain';\nimport { sortArrayIndexField } from './calculate';\nimport { DataFlowNode } from './dataflow';\n/**\n * A node that helps us track what fields we are faceting by.\n */\n\nexport class FacetNode extends DataFlowNode {\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  constructor(parent, model, name, data) {\n    super(parent);\n    this.model = model;\n    this.name = name;\n    this.data = data;\n\n    for (const channel of FACET_CHANNELS) {\n      const fieldDef = model.facet[channel];\n\n      if (fieldDef) {\n        const bin = fieldDef.bin,\n              sort = fieldDef.sort;\n        this[channel] = Object.assign({\n          name: model.getName(\"\".concat(channel, \"_domain\")),\n          fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, {\n            binSuffix: 'end'\n          })] : [])]\n        }, isSortField(sort) ? {\n          sortField: sort\n        } : isArray(sort) ? {\n          sortIndexField: sortArrayIndexField(fieldDef, channel)\n        } : {});\n      }\n    }\n\n    this.childModel = model.child;\n  }\n\n  hash() {\n    let out = \"Facet\";\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        out += \" \".concat(channel.charAt(0), \":\").concat(hash(this[channel]));\n      }\n    }\n\n    return out;\n  }\n\n  get fields() {\n    const f = [];\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel] && this[channel].fields) {\n        f.push(...this[channel].fields);\n      }\n    }\n\n    return f;\n  }\n\n  dependentFields() {\n    const depFields = new Set(this.fields);\n\n    for (const channel of FACET_CHANNELS) {\n      if (this[channel]) {\n        if (this[channel].sortField) {\n          depFields.add(this[channel].sortField.field);\n        }\n\n        if (this[channel].sortIndexField) {\n          depFields.add(this[channel].sortIndexField);\n        }\n      }\n    }\n\n    return depFields;\n  }\n\n  producedFields() {\n    return new Set(); // facet does not produce any new fields\n  }\n  /**\n   * The name to reference this source is its name.\n   */\n\n\n  getSource() {\n    return this.name;\n  }\n\n  getChildIndependentFieldsWithStep() {\n    const childIndependentFieldsWithStep = {};\n\n    for (const channel of ['x', 'y']) {\n      const childScaleComponent = this.childModel.component.scales[channel];\n\n      if (childScaleComponent && !childScaleComponent.merged) {\n        // independent scale\n        const type = childScaleComponent.get('type');\n        const range = childScaleComponent.get('range');\n\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const domain = assembleDomain(this.childModel, channel);\n          const field = getFieldFromDomain(domain);\n\n          if (field) {\n            childIndependentFieldsWithStep[channel] = field;\n          } else {\n            log.warn(\"Unknown field for \".concat(channel, \". Cannot calculate view size.\"));\n          }\n        }\n      }\n    }\n\n    return childIndependentFieldsWithStep;\n  }\n\n  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {\n    const childChannel = {\n      row: 'y',\n      column: 'x'\n    }[channel];\n    const fields = [];\n    const ops = [];\n    const as = [];\n\n    if (childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {\n      if (crossedDataName) {\n        // If there is a crossed data, calculate max\n        fields.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n        ops.push('max');\n      } else {\n        // If there is no crossed data, just calculate distinct\n        fields.push(childIndependentFieldsWithStep[childChannel]);\n        ops.push('distinct');\n      } // Although it is technically a max, just name it distinct so it's easier to refer to it\n\n\n      as.push(\"distinct_\".concat(childIndependentFieldsWithStep[childChannel]));\n    }\n\n    const _this$channel = this[channel],\n          sortField = _this$channel.sortField,\n          sortIndexField = _this$channel.sortIndexField;\n\n    if (sortField) {\n      const _sortField$op = sortField.op,\n            op = _sortField$op === void 0 ? DEFAULT_SORT_OP : _sortField$op,\n            field = sortField.field;\n      fields.push(field);\n      ops.push(op);\n      as.push(vgField(sortField, {\n        forAs: true\n      }));\n    } else if (sortIndexField) {\n      fields.push(sortIndexField);\n      ops.push('max');\n      as.push(sortIndexField);\n    }\n\n    return {\n      name: this[channel].name,\n      // Use data from the crossed one if it exist\n      source: crossedDataName || this.data,\n      transform: [Object.assign({\n        type: 'aggregate',\n        groupby: this[channel].fields\n      }, fields.length ? {\n        fields,\n        ops,\n        as\n      } : {})]\n    };\n  }\n\n  assembleFacetHeaderData(childIndependentFieldsWithStep) {\n    const columns = this.model.layout.columns;\n    const layoutHeaders = this.model.component.layoutHeaders;\n    const data = [];\n    const hasSharedAxis = {};\n\n    for (const headerChannel of HEADER_CHANNELS) {\n      for (const headerType of HEADER_TYPES) {\n        const headers = layoutHeaders[headerChannel] && layoutHeaders[headerChannel][headerType] || [];\n\n        for (const header of headers) {\n          if (header.axes && header.axes.length > 0) {\n            hasSharedAxis[headerChannel] = true;\n            break;\n          }\n        }\n      }\n\n      if (hasSharedAxis[headerChannel]) {\n        const cardinality = \"length(data(\\\"\".concat(this.facet.name, \"\\\"))\");\n        const stop = headerChannel === 'row' ? columns ? {\n          signal: \"ceil(\".concat(cardinality, \" / \").concat(columns, \")\")\n        } : 1 : columns ? {\n          signal: \"min(\".concat(cardinality, \", \").concat(columns, \")\")\n        } : {\n          signal: cardinality\n        };\n        data.push({\n          name: \"\".concat(this.facet.name, \"_\").concat(headerChannel),\n          transform: [{\n            type: 'sequence',\n            start: 0,\n            stop\n          }]\n        });\n      }\n    }\n\n    const row = hasSharedAxis.row,\n          column = hasSharedAxis.column;\n\n    if (row || column) {\n      data.unshift(this.assembleRowColumnHeaderData('facet', null, childIndependentFieldsWithStep));\n    }\n\n    return data;\n  }\n\n  assemble() {\n    const data = [];\n    let crossedDataName = null;\n    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n    const column = this.column,\n          row = this.row,\n          facet = this.facet;\n\n    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n      // Need to create a cross dataset to correctly calculate cardinality\n      crossedDataName = \"cross_\".concat(this.column.name, \"_\").concat(this.row.name);\n      const fields = [].concat(childIndependentFieldsWithStep.x || [], childIndependentFieldsWithStep.y || []);\n      const ops = fields.map(() => 'distinct');\n      data.push({\n        name: crossedDataName,\n        source: this.data,\n        transform: [{\n          type: 'aggregate',\n          groupby: this.fields,\n          fields,\n          ops\n        }]\n      });\n    }\n\n    for (const channel of [COLUMN, ROW]) {\n      if (this[channel]) {\n        data.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));\n      }\n    }\n\n    if (facet) {\n      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);\n\n      if (facetData) {\n        data.push(...facetData);\n      }\n    }\n\n    return data;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}