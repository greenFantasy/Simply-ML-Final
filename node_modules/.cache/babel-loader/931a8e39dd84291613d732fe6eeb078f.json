{"ast":null,"code":"import { SCALE_CHANNELS, SHAPE } from '../../channel';\nimport { hasConditionalFieldDef, isFieldDef } from '../../channeldef';\nimport { GEOSHAPE } from '../../mark';\nimport { NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES, scaleCompatible, scaleTypePrecedence } from '../../scale';\nimport { GEOJSON } from '../../type';\nimport { keys } from '../../util';\nimport { isUnitModel } from '../model';\nimport { defaultScaleResolve } from '../resolve';\nimport { mergeValuesWithExplicit, tieBreakByComparing } from '../split';\nimport { ScaleComponent } from './component';\nimport { parseScaleDomain } from './domain';\nimport { parseScaleProperty, parseScaleRange } from './properties';\nimport { scaleType } from './type';\nexport function parseScales(model, {\n  ignoreRange\n} = {}) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n\n  if (!ignoreRange) {\n    // range depends on zero\n    parseScaleRange(model);\n  }\n}\nexport function parseScaleCore(model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n/**\n * Parse scales for all channels of a model.\n */\n\nfunction parseUnitScaleCore(model) {\n  const encoding = model.encoding,\n        mark = model.mark;\n  return SCALE_CHANNELS.reduce((scaleComponents, channel) => {\n    let fieldDef;\n    let specifiedScale;\n    const channelDef = encoding[channel]; // Don't generate scale for shape of geoshape\n\n    if (isFieldDef(channelDef) && mark === GEOSHAPE && channel === SHAPE && channelDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      // Need to specify generic for hasConditionalFieldDef as the value type can vary across channels\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale || {};\n      const sType = scaleType(specifiedScale, channel, fieldDef, mark);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + '', true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));\n\nfunction parseNonUnitScaleCore(model) {\n  const scaleComponents = model.component.scales = {};\n  const scaleTypeWithExplicitIndex = {};\n  const resolve = model.component.resolve; // Parse each child scale and determine if a particular channel can be merged.\n\n  for (const child of model.children) {\n    parseScaleCore(child); // Instead of always merging right away -- check if it is compatible to merge first!\n\n    keys(child.component.scales).forEach(channel => {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] = resolve.scale[channel] || defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker);\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent'; // Remove from the index so they don't get merged\n\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  } // Merge each channel listed in the index\n\n\n  for (const channel of keys(scaleTypeWithExplicitIndex)) {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit); // rename each child and mark them as merged\n\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  }\n\n  return scaleComponents;\n}","map":null,"metadata":{},"sourceType":"module"}