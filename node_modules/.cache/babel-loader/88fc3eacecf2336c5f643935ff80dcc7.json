{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar _slicedToArray = require(\"/Users/rajatmittal/Documents/SimplyML/Simply-ML/panels/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tf = __importStar(require(\"@tensorflow/tfjs\"));\n\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\n\nconst dom_1 = require(\"../util/dom\");\n\nconst utils_1 = require(\"../util/utils\");\n\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a heatmap.\n *\n * ```js\n * const cols = 50;\n * const rows = 20;\n * const values = [];\n * for (let i = 0; i < cols; i++) {\n *   const col = []\n *   for (let j = 0; j < rows; j++) {\n *     col.push(i * j)\n *   }\n *   values.push(col);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Heatmap', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n * ```js\n * const data = {\n *   values: [[4, 2, 8, 20], [1, 7, 2, 10], [3, 3, 20, 13]],\n *   xTickLabels: ['cheese', 'pig', 'font'],\n *   yTickLabels: ['speed', 'smoothness', 'dexterity', 'mana'],\n * }\n *\n * // Render to visor\n * const surface = { name: 'Heatmap w Custom Labels', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n */\n\n/** @doc {heading: 'Charts', namespace: 'render'} */\n\n\nfunction heatmap(container, data, opts = {}) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const options = Object.assign({}, defaultOpts, opts);\n    const drawArea = render_utils_1.getDrawArea(container);\n    let inputValues = data.values;\n\n    if (options.rowMajor) {\n      inputValues = yield convertToRowMajor(data.values);\n    } // Data validation\n\n\n    const xTickLabels = data.xTickLabels,\n          yTickLabels = data.yTickLabels;\n\n    if (xTickLabels != null) {\n      const dimension = 0;\n      assertLabelsMatchShape(inputValues, xTickLabels, dimension);\n    } // Note that we will only do a check on the first element of the second\n    // dimension. We do not protect users against passing in a ragged array.\n\n\n    if (yTickLabels != null) {\n      const dimension = 1;\n      assertLabelsMatchShape(inputValues, yTickLabels, dimension);\n    } //\n    // Format data for vega spec; an array of objects, one for for each cell\n    // in the matrix.\n    //\n    // If custom labels are passed in for xTickLabels or yTickLabels we need\n    // to make sure they are 'unique' before mapping them to visual properties.\n    // We therefore append the index of the label to the datum that will be used\n    // for that label in the x or y axis. We could do this in all cases but choose\n    // not to to avoid unnecessary string operations.\n    //\n    // We use IDX_SEPARATOR to demarcate the added index\n\n\n    const IDX_SEPARATOR = '@tfidx@';\n    const values = [];\n\n    if (inputValues instanceof tf.Tensor) {\n      utils_1.assert(inputValues.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d'); // This is a slightly specialized version of TensorBuffer.get, inlining it\n      // avoids the overhead of a function call per data element access and is\n      // specialized to only deal with the 2d case.\n\n      const inputArray = yield inputValues.data();\n\n      const _inputValues$shape = _slicedToArray(inputValues.shape, 2),\n            numRows = _inputValues$shape[0],\n            numCols = _inputValues$shape[1];\n\n      for (let row = 0; row < numRows; row++) {\n        const x = xTickLabels ? \"\".concat(xTickLabels[row]).concat(IDX_SEPARATOR).concat(row) : row;\n\n        for (let col = 0; col < numCols; col++) {\n          const y = yTickLabels ? \"\".concat(yTickLabels[col]).concat(IDX_SEPARATOR).concat(col) : col;\n          const index = row * numCols + col;\n          const value = inputArray[index];\n          values.push({\n            x,\n            y,\n            value\n          });\n        }\n      }\n    } else {\n      const inputArray = inputValues;\n\n      for (let row = 0; row < inputArray.length; row++) {\n        const x = xTickLabels ? \"\".concat(xTickLabels[row]).concat(IDX_SEPARATOR).concat(row) : row;\n\n        for (let col = 0; col < inputArray[row].length; col++) {\n          const y = yTickLabels ? \"\".concat(yTickLabels[col]).concat(IDX_SEPARATOR).concat(col) : col;\n          const value = inputArray[row][col];\n          values.push({\n            x,\n            y,\n            value\n          });\n        }\n      }\n    }\n\n    const embedOpts = {\n      actions: false,\n      mode: 'vega-lite',\n      defaultStyle: false\n    };\n    const spec = {\n      'width': options.width || dom_1.getDefaultWidth(drawArea),\n      'height': options.height || dom_1.getDefaultHeight(drawArea),\n      'padding': 0,\n      'autosize': {\n        'type': 'fit',\n        'contains': 'padding',\n        'resize': true\n      },\n      'config': {\n        'axis': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'text': {\n          'fontSize': options.fontSize\n        },\n        'legend': {\n          'labelFontSize': options.fontSize,\n          'titleFontSize': options.fontSize\n        },\n        'scale': {\n          'bandPaddingInner': 0,\n          'bandPaddingOuter': 0\n        }\n      },\n      'data': {\n        'values': values\n      },\n      'mark': {\n        'type': 'rect',\n        'tooltip': true\n      },\n      'encoding': {\n        'x': {\n          'field': 'x',\n          'type': options.xType,\n          'title': options.xLabel,\n          'sort': 'x'\n        },\n        'y': {\n          'field': 'y',\n          'type': options.yType,\n          'title': options.yLabel,\n          'sort': 'y'\n        },\n        'fill': {\n          'field': 'value',\n          'type': 'quantitative'\n        }\n      }\n    }; //\n    // Format custom labels to remove the appended indices\n    //\n\n    const suffixPattern = \"\".concat(IDX_SEPARATOR, \"\\\\d+$\");\n    const suffixRegex = new RegExp(suffixPattern);\n\n    if (xTickLabels) {\n      // @ts-ignore\n      spec.encoding.x.axis = {\n        'labelExpr': \"replace(datum.value, regexp(/\".concat(suffixPattern, \"/), '')\")\n      };\n    }\n\n    if (yTickLabels) {\n      // @ts-ignore\n      spec.encoding.y.axis = {\n        'labelExpr': \"replace(datum.value, regexp(/\".concat(suffixPattern, \"/), '')\")\n      };\n    } // Customize tooltip formatting to remove the appended indices\n\n\n    if (xTickLabels || yTickLabels) {\n      //@ts-ignore\n      embedOpts.tooltip = {\n        sanitize: value => {\n          const valueString = String(value);\n          return valueString.replace(suffixRegex, '');\n        }\n      };\n    }\n\n    let colorRange;\n\n    switch (options.colorMap) {\n      case 'blues':\n        colorRange = ['#f7fbff', '#4292c6'];\n        break;\n\n      case 'greyscale':\n        colorRange = ['#000000', '#ffffff'];\n        break;\n\n      case 'viridis':\n      default:\n        colorRange = 'viridis';\n        break;\n    }\n\n    if (colorRange !== 'viridis') {\n      const fill = spec.encoding.fill; // @ts-ignore\n\n      fill.scale = {\n        'range': colorRange\n      };\n    }\n\n    if (options.domain) {\n      const fill = spec.encoding.fill; // @ts-ignore\n\n      if (fill.scale != null) {\n        // @ts-ignore\n        fill.scale = Object.assign({}, fill.scale, {\n          'domain': options.domain\n        });\n      } else {\n        // @ts-ignore\n        fill.scale = {\n          'domain': options.domain\n        };\n      }\n    }\n\n    yield vega_embed_1.default(drawArea, spec, embedOpts);\n  });\n}\n\nexports.heatmap = heatmap;\n\nfunction convertToRowMajor(inputValues) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let originalShape;\n    let transposed;\n\n    if (inputValues instanceof tf.Tensor) {\n      originalShape = inputValues.shape;\n      transposed = inputValues.transpose();\n    } else {\n      originalShape = [inputValues.length, inputValues[0].length];\n      transposed = tf.tidy(() => tf.tensor2d(inputValues).transpose());\n    }\n\n    utils_1.assert(transposed.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d'); // Download the intermediate tensor values and\n    // dispose the transposed tensor.\n\n    const transposedValues = yield transposed.array();\n    transposed.dispose();\n    const transposedShape = [transposedValues.length, transposedValues[0].length];\n    utils_1.assert(originalShape[0] === transposedShape[1] && originalShape[1] === transposedShape[0], \"Unexpected transposed shape. Original \".concat(originalShape, \" : Transposed \").concat(transposedShape));\n    return transposedValues;\n  });\n}\n\nfunction assertLabelsMatchShape(inputValues, labels, dimension) {\n  const shape = inputValues instanceof tf.Tensor ? inputValues.shape : [inputValues.length, inputValues[0].length];\n\n  if (dimension === 0) {\n    utils_1.assert(shape[0] === labels.length, \"Length of xTickLabels (\".concat(labels.length, \") must match number of rows\") + \" (\".concat(shape[0], \")\"));\n  } else if (dimension === 1) {\n    utils_1.assert(shape[1] === labels.length, \"Length of yTickLabels (\".concat(labels.length, \") must match number of columns (\").concat(shape[1], \")\"));\n  }\n}\n\nconst defaultOpts = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'ordinal',\n  yType: 'ordinal',\n  colorMap: 'viridis',\n  fontSize: 12,\n  domain: null,\n  rowMajor: false\n};","map":null,"metadata":{},"sourceType":"script"}