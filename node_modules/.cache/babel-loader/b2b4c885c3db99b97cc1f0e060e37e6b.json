{"ast":null,"code":"import { isString } from 'vega-util';\nimport { getPositionScaleChannel } from '../channel';\nimport * as vlFieldDef from '../channeldef';\nimport { initConfig, stripAndRedirectConfig } from '../config';\nimport * as log from '../log';\nimport { normalize } from '../normalize/index';\nimport { extractTopLevelProperties, getFitType, isFitType } from '../spec/toplevel';\nimport { keys, mergeDeep } from '../util';\nimport { buildModel } from './buildmodel';\nimport { assembleRootData } from './data/assemble';\nimport { optimizeDataflow } from './data/optimize';\n/**\n * Vega-Lite's main function, for compiling Vega-lite spec into Vega spec.\n *\n * At a high-level, we make the following transformations in different phases:\n *\n * Input spec\n *     |\n *     |  (Normalization)\n *     v\n * Normalized Spec (Row/Column channels in single-view specs becomes faceted specs, composite marks becomes layered specs.)\n *     |\n *     |  (Build Model)\n *     v\n * A model tree of the spec\n *     |\n *     |  (Parse)\n *     v\n * A model tree with parsed components (intermediate structure of visualization primitives in a format that can be easily merged)\n *     |\n *     | (Optimize)\n *     v\n * A model tree with parsed components with the data component optimized\n *     |\n *     | (Assemble)\n *     v\n * Vega spec\n */\n\nexport function compile(inputSpec, opt = {}) {\n  // 0. Augment opt with default opts\n  if (opt.logger) {\n    // set the singleton logger to the provided logger\n    log.set(opt.logger);\n  }\n\n  if (opt.fieldTitle) {\n    // set the singleton field title formatter\n    vlFieldDef.setTitleFormatter(opt.fieldTitle);\n  }\n\n  try {\n    // 1. Initialize config by deep merging default config with the config provided via option and the input spec.\n    const config = initConfig(mergeDeep({}, opt.config, inputSpec.config)); // 2. Normalize: Convert input spec -> normalized spec\n    // - Decompose all extended unit specs into composition of unit spec.  For example, a box plot get expanded into multiple layers of bars, ticks, and rules. The shorthand row/column channel is also expanded to a facet spec.\n    // - Normalize autosize and width or height spec\n\n    const spec = normalize(inputSpec, config); // 3. Build Model: normalized spec -> Model (a tree structure)\n    // This phases instantiates the models with default config by doing a top-down traversal. This allows us to pass properties that child models derive from their parents via their constructors.\n    // See the abstract `Model` class and its children (UnitModel, LayerModel, FacetModel, RepeatModel, ConcatModel) for different types of models.\n\n    const model = buildModel(spec, null, '', undefined, undefined, config); // 4 Parse: Model --> Model with components\n    // Note that components = intermediate representations that are equivalent to Vega specs.\n    // We need these intermediate representation because we need to merge many visualization \"components\" like projections, scales, axes, and legends.\n    // We will later convert these components into actual Vega specs in the assemble phase.\n    // In this phase, we do a bottom-up traversal over the whole tree to\n    // parse for each type of components once (e.g., data, layout, mark, scale).\n    // By doing bottom-up traversal, we start parsing components of unit specs and\n    // then merge child components of parent composite specs.\n    //\n    // Please see inside model.parse() for order of different components parsed.\n\n    model.parse(); // draw(model.component.data.sources);\n    // 5. Optimize the dataflow.  This will modify the data component of the model.\n\n    optimizeDataflow(model.component.data, model); // 6. Assemble: convert model components --> Vega Spec.\n\n    return assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (opt.logger) {\n      log.reset();\n    } // Reset the singleton field title formatter if provided\n\n\n    if (opt.fieldTitle) {\n      vlFieldDef.resetTitleFormatter();\n    }\n  }\n}\n\nfunction getTopLevelProperties(inputSpec, autosize, config, model) {\n  const width = model.component.layoutSize.get('width');\n  const height = model.component.layoutSize.get('height');\n\n  if (isString(autosize)) {\n    autosize = {\n      type: autosize\n    };\n  }\n\n  if (width && height && isFitType(autosize.type)) {\n    if (width === 'step' && height === 'step') {\n      log.warn(log.message.droppingFit());\n      autosize.type = 'pad';\n    } else if (width === 'step' || height === 'step') {\n      // effectively XOR, because else if\n      // get step dimension\n      const sizeType = width === 'step' ? 'width' : 'height'; // log that we're dropping fit for respective channel\n\n      log.warn(log.message.droppingFit(getPositionScaleChannel(sizeType))); // setting type to inverse fit (so if we dropped fit-x, type is now fit-y)\n\n      const inverseSizeType = sizeType === 'width' ? 'height' : 'width';\n      autosize.type = getFitType(inverseSizeType);\n    }\n  }\n\n  return Object.assign(Object.assign(Object.assign({}, keys(autosize).length === 1 && autosize.type ? autosize.type === 'pad' ? {} : {\n    autosize: autosize.type\n  } : {\n    autosize\n  }), extractTopLevelProperties(config)), extractTopLevelProperties(inputSpec));\n}\n/*\n * Assemble the top-level model.\n *\n * Note: this couldn't be `model.assemble()` since the top-level model\n * needs some special treatment to generate top-level properties.\n */\n\n\nfunction assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {\n  // Config with Vega-Lite only config removed.\n  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : undefined;\n  const data = [].concat(model.assembleSelectionData([]), // only assemble data in the root\n  assembleRootData(model.component.data, datasets));\n  const projections = model.assembleProjections();\n  const title = model.assembleTitle();\n  const style = model.assembleGroupStyle();\n  const encodeEntry = model.assembleGroupEncodeEntry(true);\n  let layoutSignals = model.assembleLayoutSignals(); // move width and height signals with values to top level\n\n  layoutSignals = layoutSignals.filter(signal => {\n    if ((signal.name === 'width' || signal.name === 'height') && signal.value !== undefined) {\n      topLevelProperties[signal.name] = +signal.value;\n      return false;\n    }\n\n    return true;\n  });\n  const output = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n    $schema: 'https://vega.github.io/schema/vega/v5.json'\n  }, model.description ? {\n    description: model.description\n  } : {}), topLevelProperties), title ? {\n    title\n  } : {}), style ? {\n    style\n  } : {}), encodeEntry ? {\n    encode: {\n      update: encodeEntry\n    }\n  } : {}), {\n    data\n  }), projections.length > 0 ? {\n    projections: projections\n  } : {}), model.assembleGroup([...layoutSignals, ...model.assembleSelectionTopLevelSignals([])])), vgConfig ? {\n    config: vgConfig\n  } : {}), usermeta ? {\n    usermeta\n  } : {});\n  return {\n    spec: output // TODO: add warning / errors here\n\n  };\n}","map":null,"metadata":{},"sourceType":"module"}