{"ast":null,"code":"import _toArray from \"/Users/rajatmittal/Documents/SMLTest/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport { isString } from 'vega-util';\nimport { binToString, isBinning } from '../../bin';\nimport { binRequiresRange, isTypedFieldDef, normalizeBin, vgField } from '../../channeldef';\nimport { duplicate, hash, keys, replacePathInField, unique, vals } from '../../util';\nimport { binFormatExpression } from '../common';\nimport { isUnitModel } from '../model';\nimport { DataFlowNode } from './dataflow';\n\nfunction rangeFormula(model, fieldDef, channel, config) {\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n    const guide = isUnitModel(model) ? model.axis(channel) || model.legend(channel) || {} : {};\n    const startField = vgField(fieldDef, {\n      expr: 'datum'\n    });\n    const endField = vgField(fieldDef, {\n      expr: 'datum',\n      binSuffix: 'end'\n    });\n    return {\n      formulaAs: vgField(fieldDef, {\n        binSuffix: 'range',\n        forAs: true\n      }),\n      formula: binFormatExpression(startField, endField, guide.format, config)\n    };\n  }\n\n  return {};\n}\n\nfunction binKey(bin, field) {\n  return \"\".concat(binToString(bin), \"_\").concat(field);\n}\n\nfunction getSignalsFromModel(model, key) {\n  return {\n    signal: model.getName(\"\".concat(key, \"_bins\")),\n    extentSignal: model.getName(\"\".concat(key, \"_extent\"))\n  };\n}\n\nexport function getBinSignalName(model, field, bin) {\n  const normalizedBin = normalizeBin(bin, undefined) || {};\n  const key = binKey(normalizedBin, field);\n  return model.getName(\"\".concat(key, \"_bins\"));\n}\n\nfunction isBinTransform(t) {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t, bin, model) {\n  let as;\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, \"\".concat(t.as, \"_end\")] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {\n      forAs: true\n    }), vgField(t, {\n      binSuffix: 'end',\n      forAs: true\n    })];\n  }\n\n  const normalizedBin = normalizeBin(bin, undefined) || {};\n  const key = binKey(normalizedBin, t.field);\n\n  const _getSignalsFromModel = getSignalsFromModel(model, key),\n        signal = _getSignalsFromModel.signal,\n        extentSignal = _getSignalsFromModel.extentSignal;\n\n  const binComponent = Object.assign(Object.assign({\n    bin: normalizedBin,\n    field: t.field,\n    as: [as]\n  }, signal ? {\n    signal\n  } : {}), extentSignal ? {\n    extentSignal\n  } : {});\n  return {\n    key,\n    binComponent\n  };\n}\n\nexport class BinNode extends DataFlowNode {\n  constructor(parent, bins) {\n    super(parent);\n    this.bins = bins;\n  }\n\n  clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  static makeFromEncoding(parent, model) {\n    const bins = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {\n      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {\n        const _createBinComponent = createBinComponent(fieldDef, fieldDef.bin, model),\n              key = _createBinComponent.key,\n              binComponent = _createBinComponent.binComponent;\n\n        binComponentIndex[key] = Object.assign(Object.assign(Object.assign({}, binComponent), binComponentIndex[key]), rangeFormula(model, fieldDef, channel, model.config));\n      }\n\n      return binComponentIndex;\n    }, {});\n\n    if (keys(bins).length === 0) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n\n\n  static makeFromTransform(parent, t, model) {\n    const _createBinComponent2 = createBinComponent(t, t.bin, model),\n          key = _createBinComponent2.key,\n          binComponent = _createBinComponent2.binComponent;\n\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n  /**\n   * Merge bin nodes. This method either integrates the bin config from the other node\n   * or if this node already has a bin config, renames the corresponding signal in the model.\n   */\n\n\n  merge(other, renameSignal) {\n    for (const key of keys(other.bins)) {\n      if (key in this.bins) {\n        renameSignal(other.bins[key].signal, this.bins[key].signal); // Ensure that we don't have duplicate names for signal pairs\n\n        this.bins[key].as = unique([...this.bins[key].as, ...other.bins[key].as], hash);\n      } else {\n        this.bins[key] = other.bins[key];\n      }\n    }\n\n    for (const child of other.children) {\n      other.removeChild(child);\n      child.parent = this;\n    }\n\n    other.remove();\n  }\n\n  producedFields() {\n    return new Set(vals(this.bins).map(c => c.as).flat(2));\n  }\n\n  dependentFields() {\n    return new Set(vals(this.bins).map(c => c.field));\n  }\n\n  hash() {\n    return \"Bin \".concat(hash(this.bins));\n  }\n\n  assemble() {\n    return vals(this.bins).flatMap(bin => {\n      const transform = [];\n\n      const _bin$as = _toArray(bin.as),\n            binAs = _bin$as[0],\n            remainingAs = _bin$as.slice(1);\n\n      const binTrans = Object.assign({\n        type: 'bin',\n        field: replacePathInField(bin.field),\n        as: binAs,\n        signal: bin.signal\n      }, bin.bin);\n\n      if (!bin.bin.extent && bin.extentSignal) {\n        transform.push({\n          type: 'extent',\n          field: replacePathInField(bin.field),\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {\n          signal: bin.extentSignal\n        };\n      }\n\n      transform.push(binTrans);\n\n      for (const as of remainingAs) {\n        for (let i = 0; i < 2; i++) {\n          transform.push({\n            type: 'formula',\n            expr: vgField({\n              field: binAs[i]\n            }, {\n              expr: 'datum'\n            }),\n            as: as[i]\n          });\n        }\n      }\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n\n      return transform;\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}