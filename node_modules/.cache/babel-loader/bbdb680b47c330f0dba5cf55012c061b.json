{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { selector as parseSelector } from 'vega-event-selector';\nimport { identity, isArray, stringValue } from 'vega-util';\nimport { forEachSelection, MODIFY, SELECTION_DOMAIN, STORE, unitName, VL_SELECTION_RESOLVE } from '.';\nimport { dateTimeExpr, isDateTime } from '../../datetime';\nimport { warn } from '../../log';\nimport { keys, varName } from '../../util';\nimport { isUnitModel } from '../model';\nimport { forEachTransform } from './transforms/transforms';\nexport function assembleInit(init, isExpr = true, wrap = identity) {\n  if (isArray(init)) {\n    const assembled = init.map(v => assembleInit(v, isExpr, wrap));\n    return isExpr ? \"[\".concat(assembled.join(', '), \"]\") : assembled;\n  } else if (isDateTime(init)) {\n    return wrap(dateTimeExpr(init, false, !isExpr));\n  }\n\n  return isExpr ? wrap(JSON.stringify(init)) : init;\n}\nexport function assembleUnitSelectionSignals(model, signals) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n    signals.push(...selCompiler.signals(model, selCmpt));\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n    signals.push({\n      name: name + MODIFY,\n      update: \"modify(\".concat(stringValue(selCmpt.name + STORE), \", \").concat(modifyExpr, \")\")\n    });\n  });\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleFacetSignals(model, signals) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: \"isTuple(facet) ? facet : group(\".concat(name, \").datum\")\n      }]\n    });\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleTopLevelSignals(model, signals) {\n  let hasSelections = false;\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    const store = stringValue(name + STORE);\n    const hasSg = signals.filter(s => s.name === name);\n\n    if (!hasSg.length) {\n      signals.push({\n        name: selCmpt.name,\n        update: \"\".concat(VL_SELECTION_RESOLVE, \"(\").concat(store) + (selCmpt.resolve === 'global' ? ')' : \", \".concat(stringValue(selCmpt.resolve), \")\"))\n      });\n    }\n\n    hasSelections = true;\n\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n  });\n\n  if (hasSelections) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n\n    if (!hasUnit.length) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{\n          events: 'mousemove',\n          update: 'isTuple(group()) ? group() : unit'\n        }]\n      });\n    }\n  }\n\n  return cleanupEmptyOnArray(signals);\n}\nexport function assembleUnitSelectionData(model, data) {\n  const dataCopy = [...data];\n  forEachSelection(model, selCmpt => {\n    const init = {\n      name: selCmpt.name + STORE\n    };\n\n    if (selCmpt.init) {\n      const fields = selCmpt.project.items.map(proj => {\n        const signals = proj.signals,\n              rest = __rest(proj, [\"signals\"]);\n\n        return rest;\n      });\n      const insert = selCmpt.init.map(i => assembleInit(i, false));\n      init.values = selCmpt.type === 'interval' ? [{\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields,\n        values: insert\n      }] : insert.map(i => ({\n        unit: unitName(model, {\n          escape: false\n        }),\n        fields,\n        values: i\n      }));\n    }\n\n    const contains = dataCopy.filter(d => d.name === selCmpt.name + STORE);\n\n    if (!contains.length) {\n      dataCopy.push(init);\n    }\n  });\n  return dataCopy;\n}\nexport function assembleUnitSelectionMarks(model, marks) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n  return marks;\n}\nexport function assembleLayerSelectionMarks(model, marks) {\n  for (const child of model.children) {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  }\n\n  return marks;\n} // Selections are parsed _after_ scales. If a scale domain is set to\n// use a selection, the SELECTION_DOMAIN constant is used as the\n// domainRaw.signal during scale.parse and then replaced with the necessary\n// selection expression function during scale.assemble. To not pollute the\n// type signatures to account for this setup, the selection domain definition\n// is coerced to a string and appended to SELECTION_DOMAIN.\n\nexport function assembleSelectionScaleDomain(model, domainRaw) {\n  const selDomain = JSON.parse(domainRaw.signal.replace(SELECTION_DOMAIN, ''));\n  const name = varName(selDomain.selection);\n  const encoding = selDomain.encoding;\n  let field = selDomain.field;\n  let selCmpt = model.component.selection && model.component.selection[name];\n\n  if (selCmpt) {\n    warn('Use \"bind\": \"scales\" to setup a binding for scales and selections within the same view.');\n  } else {\n    selCmpt = model.getSelectionComponent(name, selDomain.selection);\n\n    if (!encoding && !field) {\n      field = selCmpt.project.items[0].field;\n\n      if (selCmpt.project.items.length > 1) {\n        warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n      }\n    } else if (encoding && !field) {\n      const encodings = selCmpt.project.items.filter(p => p.channel === encoding);\n\n      if (!encodings.length || encodings.length > 1) {\n        field = selCmpt.project.items[0].field;\n        warn((!encodings.length ? 'No ' : 'Multiple ') + \"matching \".concat(stringValue(encoding), \" encoding found for selection \").concat(stringValue(selDomain.selection), \". \") + \"Using \\\"field\\\": \".concat(stringValue(field), \".\"));\n      } else {\n        field = encodings[0].field;\n      }\n    }\n\n    return {\n      signal: \"\".concat(name, \"[\").concat(stringValue(field), \"]\")\n    };\n  }\n\n  return {\n    signal: 'null'\n  };\n}\n\nfunction cleanupEmptyOnArray(signals) {\n  return signals.map(s => {\n    if (s.on && !s.on.length) delete s.on;\n    return s;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}