{"ast":null,"code":"import * as log from '../../log';\nimport { checkLinks } from './debug';\nimport { BottomUpOptimizer } from './optimizer';\nimport * as optimizers from './optimizers';\nexport const FACET_SCALE_PREFIX = 'scale_';\nexport const MAX_OPTIMIZATION_RUNS = 5;\n/**\n * Return all leaf nodes.\n */\n\nfunction getLeaves(roots) {\n  const leaves = [];\n\n  function append(node) {\n    if (node.numChildren() === 0) {\n      leaves.push(node);\n    } else {\n      node.children.forEach(append);\n    }\n  }\n\n  roots.forEach(append);\n  return leaves;\n}\n\nexport function isTrue(x) {\n  return x;\n}\n/**\n * Run the specified optimizer on the provided nodes.\n *\n * @param optimizer The optimizer instance to run.\n * @param nodes A set of nodes to optimize.\n * @param flag Flag that will be or'ed with return valued from optimization calls to the nodes.\n */\n\nfunction runOptimizer(optimizer, nodes) {\n  const flags = nodes.map(node => {\n    if (optimizer instanceof BottomUpOptimizer) {\n      const runFlags = optimizer.optimizeNextFromLeaves(node);\n      optimizer.reset();\n      return runFlags;\n    } else {\n      return optimizer.run(node);\n    }\n  });\n  return flags.some(isTrue);\n}\n\nfunction optimizationDataflowHelper(dataComponent, model) {\n  let roots = dataComponent.sources;\n  const mutatedFlags = new Set();\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnnecessaryNodes(), roots)); // remove source nodes that don't have any children because they also don't have output nodes\n\n  roots = roots.filter(r => r.numChildren() > 0);\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveUnusedSubtrees(), getLeaves(roots)));\n  roots = roots.filter(r => r.numChildren() > 0);\n  mutatedFlags.add(runOptimizer(new optimizers.MoveParseUp(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeBins(model), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.RemoveDuplicateTimeUnits(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeParse(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeAggregates(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeTimeUnits(), getLeaves(roots)));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeIdenticalNodes(), roots));\n  mutatedFlags.add(runOptimizer(new optimizers.MergeOutputs(), getLeaves(roots)));\n  dataComponent.sources = roots;\n  return mutatedFlags.has(true);\n}\n/**\n * Optimizes the dataflow of the passed in data component.\n */\n\n\nexport function optimizeDataflow(data, model) {\n  // check before optimizations\n  checkLinks(data.sources);\n  let firstPassCounter = 0;\n  let secondPassCounter = 0;\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model)) {\n      break;\n    }\n\n    firstPassCounter++;\n  } // move facets down and make a copy of the subtree so that we can have scales at the top level\n\n\n  data.sources.map(optimizers.moveFacetDown);\n\n  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {\n    if (!optimizationDataflowHelper(data, model)) {\n      break;\n    }\n\n    secondPassCounter++;\n  } // check after optimizations\n\n\n  checkLinks(data.sources);\n\n  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {\n    log.warn(\"Maximum optimization runs(\".concat(MAX_OPTIMIZATION_RUNS, \") reached.\"));\n  }\n}","map":null,"metadata":{},"sourceType":"module"}