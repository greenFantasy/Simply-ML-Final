{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { array, stringValue } from 'vega-util';\nimport { STORE, TUPLE, unitName } from '.';\nimport { X, Y } from '../../channel';\nimport { warn } from '../../log';\nimport { hasContinuousDomain } from '../../scale';\nimport { keys } from '../../util';\nimport { assembleInit } from './assemble';\nimport { TUPLE_FIELDS } from './transforms/project';\nimport scales from './transforms/scales';\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\nconst interval = {\n  signals: (model, selCmpt) => {\n    const name = selCmpt.name;\n    const fieldsSg = name + TUPLE_FIELDS;\n    const hasScales = scales.has(selCmpt);\n    const signals = [];\n    const dataSignals = [];\n    const scaleTriggers = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = \"!event.item || event.item.mark.name !== \".concat(stringValue(name + BRUSH));\n      events(selCmpt, (on, evt) => {\n        const filters = array(evt.between[0].filter || (evt.between[0].filter = []));\n\n        if (filters.indexOf(filterExpr) < 0) {\n          filters.push(filterExpr);\n        }\n\n        return on;\n      });\n    }\n\n    selCmpt.project.items.forEach((proj, i) => {\n      const channel = proj.channel;\n\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      const init = selCmpt.init ? selCmpt.init[i] : null;\n      const cs = channelSignals(model, selCmpt, proj, init);\n      const dname = proj.signals.data;\n      const vname = proj.signals.visual;\n      const scaleName = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n      signals.push(...cs);\n      dataSignals.push(dname);\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr: \"(!isArray(\".concat(dname, \") || \") + \"(\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[0] === \").concat(toNum).concat(dname, \"[0] && \") + \"\".concat(toNum, \"invert(\").concat(scaleName, \", \").concat(vname, \")[1] === \").concat(toNum).concat(dname, \"[1]))\")\n      });\n    }); // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n\n    if (!hasScales) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        value: {},\n        on: [{\n          events: scaleTriggers.map(t => ({\n            scale: t.scaleName\n          })),\n          update: scaleTriggers.map(t => t.expr).join(' && ') + \" ? \".concat(name + SCALE_TRIGGER, \" : {}\")\n        }]\n      });\n    } // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n\n\n    const init = selCmpt.init;\n    const update = \"unit: \".concat(unitName(model), \", fields: \").concat(fieldsSg, \", values\");\n    return signals.concat(Object.assign(Object.assign({\n      name: name + TUPLE\n    }, init ? {\n      init: \"{\".concat(update, \": \").concat(assembleInit(init), \"}\")\n    } : {}), {\n      on: [{\n        events: [{\n          signal: dataSignals.join(' || ')\n        }],\n        update: dataSignals.join(' && ') + \" ? {\".concat(update, \": [\").concat(dataSignals, \"]} : null\")\n      }]\n    }));\n  },\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'true' : \"{unit: \".concat(unitName(model), \"}\"));\n  },\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const _selCmpt$project$has = selCmpt.project.has,\n          x = _selCmpt$project$has.x,\n          y = _selCmpt$project$has.y;\n    const xvname = x && x.signals.visual;\n    const yvname = y && y.signals.visual;\n    const store = \"data(\".concat(stringValue(selCmpt.name + STORE), \")\"); // Do not add a brush if we're binding to scales.\n\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    const update = {\n      x: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      y: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[0]\")\n      } : {\n        value: 0\n      },\n      x2: x !== undefined ? {\n        signal: \"\".concat(xvname, \"[1]\")\n      } : {\n        field: {\n          group: 'width'\n        }\n      },\n      y2: y !== undefined ? {\n        signal: \"\".concat(yvname, \"[1]\")\n      } : {\n        field: {\n          group: 'height'\n        }\n      }\n    }; // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [Object.assign({\n          test: \"\".concat(store, \".length && \").concat(store, \"[0].unit === \").concat(unitName(model))\n        }, update[key]), {\n          value: 0\n        }];\n      }\n    } // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n\n\n    const _a = selCmpt.mark,\n          fill = _a.fill,\n          fillOpacity = _a.fillOpacity,\n          stroke = __rest(_a, [\"fill\", \"fillOpacity\"]);\n\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [{\n        test: [x !== undefined && \"\".concat(xvname, \"[0] !== \").concat(xvname, \"[1]\"), y !== undefined && \"\".concat(yvname, \"[0] !== \").concat(yvname, \"[1]\")].filter(t => t).join(' && '),\n        value: stroke[k]\n      }, {\n        value: null\n      }];\n      return def;\n    }, {});\n    return [{\n      name: name + BRUSH + '_bg',\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: fill\n          },\n          fillOpacity: {\n            value: fillOpacity\n          }\n        },\n        update: update\n      }\n    }, ...marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {\n            value: 'transparent'\n          }\n        },\n        update: Object.assign(Object.assign({}, update), vgStroke)\n      }\n    }];\n  }\n};\nexport default interval;\n/**\n * Returns the visual and data signals for an interval selection.\n */\n\nfunction channelSignals(model, selCmpt, proj, init) {\n  const channel = proj.channel;\n  const vname = proj.signals.visual;\n  const dname = proj.signals.data;\n  const hasScales = scales.has(selCmpt);\n  const scaleName = stringValue(model.scaleName(channel));\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n\n  const scaled = str => \"scale(\".concat(scaleName, \", \").concat(str, \")\");\n\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = \"\".concat(channel, \"(unit)\");\n  const on = events(selCmpt, (def, evt) => {\n    return [...def, {\n      events: evt.between[0],\n      update: \"[\".concat(coord, \", \").concat(coord, \"]\")\n    }, {\n      events: evt,\n      update: \"[\".concat(vname, \"[0], clamp(\").concat(coord, \", 0, \").concat(size, \")]\")\n    } // Brush End\n    ];\n  }); // React to pan/zooms of continuous scales. Non-continuous scales\n  // (band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n\n  on.push({\n    events: {\n      signal: selCmpt.name + SCALE_TRIGGER\n    },\n    update: hasContinuousDomain(scaleType) ? \"[\".concat(scaled(\"\".concat(dname, \"[0]\")), \", \").concat(scaled(\"\".concat(dname, \"[1]\")), \"]\") : \"[0, 0]\"\n  });\n  return hasScales ? [{\n    name: dname,\n    on: []\n  }] : [Object.assign(Object.assign({\n    name: vname\n  }, init ? {\n    init: assembleInit(init, true, scaled)\n  } : {\n    value: []\n  }), {\n    on: on\n  }), Object.assign(Object.assign({\n    name: dname\n  }, init ? {\n    init: assembleInit(init)\n  } : {}), {\n    on: [{\n      events: {\n        signal: vname\n      },\n      update: \"\".concat(vname, \"[0] === \").concat(vname, \"[1] ? null : invert(\").concat(scaleName, \", \").concat(vname, \")\")\n    }]\n  })];\n}\n\nfunction events(selCmpt, cb) {\n  return selCmpt.events.reduce((on, evt) => {\n    if (!evt.between) {\n      warn(\"\".concat(evt, \" is not an ordered event stream for interval selections.\"));\n      return on;\n    }\n\n    return cb(on, evt);\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}