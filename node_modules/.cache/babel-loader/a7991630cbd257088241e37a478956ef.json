{"ast":null,"code":"import { entries, uniqueId } from './../../util';\nimport { SourceNode } from './source';\n/**\n * Print debug information for dataflow tree.\n */\n\nexport function debug(node) {\n  console.log(\"\".concat(node.constructor.name).concat(node.debugName ? \"(\".concat(node.debugName, \")\") : '', \" -> \").concat(node.children.map(c => {\n    return \"\".concat(c.constructor.name).concat(c.debugName ? \" (\".concat(c.debugName, \")\") : '');\n  })));\n  console.log(node);\n  node.children.forEach(debug);\n}\n/**\n * Print the dataflow tree as graphviz.\n *\n * Render the output in http://viz-js.com/.\n */\n\nexport function draw(roots) {\n  // check the graph before printing it since the logic below assumes a consistent graph\n  checkLinks(roots);\n  const nodes = {};\n  const edges = [];\n\n  function getId(node) {\n    let id = node['__uniqueid'];\n\n    if (id === undefined) {\n      id = uniqueId();\n      node['__uniqueid'] = id;\n    }\n\n    return id;\n  }\n\n  function getLabel(node) {\n    const out = [node.constructor.name.slice(0, -4)];\n\n    if (node.debugName) {\n      out.push(\"<i>\".concat(node.debugName, \"</i>\"));\n    } else if (node instanceof SourceNode) {\n      if (node.data.name || node.data.url) {\n        out.push(\"<i>\".concat(node.data.name || node.data.url, \"</i>\"));\n      }\n    }\n\n    const dep = node.dependentFields();\n\n    if (dep && dep.size) {\n      out.push(\"<font color=\\\"grey\\\" point-size=\\\"10\\\">IN:</font> \".concat([...node.dependentFields()].join(', ')));\n    }\n\n    const prod = node.producedFields();\n\n    if (prod && prod.size) {\n      out.push(\"<font color=\\\"grey\\\" point-size=\\\"10\\\">OUT:</font> \".concat([...node.producedFields()].join(', ')));\n    }\n\n    return out.join('<br/>');\n  }\n\n  function collector(node) {\n    const id = getId(node);\n    nodes[id] = {\n      id: id,\n      label: getLabel(node),\n      hash: node instanceof SourceNode ? node.data.url || node.data.name || node.debugName : String(node.hash()).replace(/\"/g, '')\n    };\n\n    for (const child of node.children) {\n      edges.push([id, getId(child)]);\n      collector(child);\n    }\n  }\n\n  roots.forEach(n => collector(n));\n  const dot = \"digraph DataFlow {\\n  rankdir = TB;\\n  node [shape=record]\\n  \".concat(entries(nodes).map(({\n    key,\n    value\n  }) => \"  \\\"\".concat(key, \"\\\" [\\n    label = <\").concat(value.label, \">;\\n    tooltip = \\\"[\").concat(value.id, \"]&#010;\").concat(value.hash, \"\\\"\\n  ]\")).join('\\n'), \"\\n\\n  \").concat(edges.map(([source, target]) => \"\\\"\".concat(source, \"\\\" -> \\\"\").concat(target, \"\\\"\")).join(' '), \"\\n}\");\n  console.log(dot);\n  return dot;\n}\n/**\n * Iterates over a dataflow graph and checks whether all links are consistent.\n */\n\nexport function checkLinks(nodes) {\n  for (const node of nodes) {\n    for (const child of node.children) {\n      if (child.parent !== node) {\n        console.error('Dataflow graph is inconsistent.', node, child);\n        return false;\n      }\n    }\n\n    if (!checkLinks(node.children)) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"module"}