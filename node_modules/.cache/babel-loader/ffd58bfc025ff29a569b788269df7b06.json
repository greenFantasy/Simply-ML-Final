{"ast":null,"code":"import { stringValue } from 'vega-util';\nimport { VL_SELECTION_RESOLVE } from '..';\nimport { isScaleChannel, X, Y } from '../../../channel';\nimport * as log from '../../../log';\nimport { hasContinuousDomain } from '../../../scale';\nimport { varName } from '../../../util';\nimport { isLayerModel } from '../../model';\nconst scaleBindings = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n  parse: (model, selCmpt) => {\n    const name = varName(selCmpt.name);\n    const bound = selCmpt.scales = [];\n\n    for (const proj of selCmpt.project.items) {\n      const channel = proj.channel;\n\n      if (!isScaleChannel(channel)) {\n        continue;\n      }\n\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (!scale || !hasContinuousDomain(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        continue;\n      }\n\n      scale.set('domainRaw', {\n        signal: \"\".concat(name, \"[\").concat(stringValue(proj.field), \"]\")\n      }, true);\n      bound.push(proj); // Bind both x/y for diag plot of repeated views.\n\n      if (model.repeater && model.repeater.row === model.repeater.column) {\n        const scale2 = model.getScaleComponent(channel === X ? Y : X);\n        scale2.set('domainRaw', {\n          signal: \"\".concat(name, \"[\").concat(stringValue(proj.field), \"]\")\n        }, true);\n      }\n    }\n  },\n  topLevelSignals: (model, selCmpt, signals) => {\n    const bound = selCmpt.scales.filter(proj => !signals.filter(s => s.name === proj.signals.data).length); // Top-level signals are only needed for multiview displays and if this\n    // view's top-level signals haven't already been generated.\n\n    if (!model.parent || isTopLevelLayer(model) || !bound.length) {\n      return signals;\n    } // vlSelectionResolve does not account for the behavior of bound scales in\n    // multiview displays. Each unit view adds a tuple to the store, but the\n    // state of the selection is the unit selection most recently updated. This\n    // state is captured by the top-level signals that we insert and \"push\n    // outer\" to from within the units. We need to reassemble this state into\n    // the top-level named signal, except no single selCmpt has a global view.\n\n\n    const namedSg = signals.filter(s => s.name === selCmpt.name)[0];\n    let update = namedSg.update;\n\n    if (update.indexOf(VL_SELECTION_RESOLVE) >= 0) {\n      namedSg.update = \"{\".concat(bound.map(proj => \"\".concat(stringValue(proj.field), \": \").concat(proj.signals.data)).join(', '), \"}\");\n    } else {\n      for (const proj of bound) {\n        const mapping = \"\".concat(stringValue(proj.field), \": \").concat(proj.signals.data);\n\n        if (update.indexOf(mapping) < 0) {\n          update = \"\".concat(update.substring(0, update.length - 1), \", \").concat(mapping, \"}\");\n        }\n      }\n\n      namedSg.update = update;\n    }\n\n    return signals.concat(bound.map(proj => ({\n      name: proj.signals.data\n    })));\n  },\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals with multiview displays.\n    if (model.parent && !isTopLevelLayer(model)) {\n      for (const proj of selCmpt.scales) {\n        const signal = signals.filter(s => s.name === proj.signals.data)[0];\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      }\n    }\n\n    return signals;\n  }\n};\nexport default scaleBindings;\nexport function domain(model, channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return \"domain(\".concat(scale, \")\");\n}\n\nfunction isTopLevelLayer(model) {\n  return model.parent && isLayerModel(model.parent) && (!model.parent.parent || isTopLevelLayer(model.parent.parent));\n}","map":null,"metadata":{},"sourceType":"module"}