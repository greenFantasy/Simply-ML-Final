{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { isArray, isBoolean, isString } from 'vega-util';\nimport { isContinuous, isFieldDef } from '../channeldef';\nimport { fieldDefs } from '../encoding';\nimport * as log from '../log';\nimport { isMarkDef } from '../mark';\nimport { getFirstDefined } from '../util';\nexport function filterTooltipWithAggregatedField(oldEncoding) {\n  const tooltip = oldEncoding.tooltip,\n        filteredEncoding = __rest(oldEncoding, [\"tooltip\"]);\n\n  if (!tooltip) {\n    return {\n      filteredEncoding: oldEncoding\n    };\n  }\n\n  let customTooltipWithAggregatedField;\n  let customTooltipWithoutAggregatedField;\n\n  if (isArray(tooltip)) {\n    tooltip.forEach(t => {\n      if (t.aggregate) {\n        if (!customTooltipWithAggregatedField) {\n          customTooltipWithAggregatedField = [];\n        }\n\n        customTooltipWithAggregatedField.push(t);\n      } else {\n        if (!customTooltipWithoutAggregatedField) {\n          customTooltipWithoutAggregatedField = [];\n        }\n\n        customTooltipWithoutAggregatedField.push(t);\n      }\n    });\n\n    if (customTooltipWithAggregatedField) {\n      filteredEncoding.tooltip = customTooltipWithAggregatedField;\n    }\n  } else {\n    if (tooltip['aggregate']) {\n      filteredEncoding.tooltip = tooltip;\n    } else {\n      customTooltipWithoutAggregatedField = tooltip;\n    }\n  }\n\n  if (isArray(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {\n    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];\n  }\n\n  return {\n    customTooltipWithoutAggregatedField,\n    filteredEncoding\n  };\n}\nexport function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {\n  if ('tooltip' in encodingWithoutContinuousAxis) {\n    return {\n      tooltip: encodingWithoutContinuousAxis.tooltip\n    };\n  }\n\n  const fiveSummaryTooltip = tooltipSummary.map(({\n    fieldPrefix,\n    titlePrefix\n  }) => ({\n    field: fieldPrefix + continuousAxisChannelDef.field,\n    type: continuousAxisChannelDef.type,\n    title: titlePrefix + (withFieldName ? ' of ' + continuousAxisChannelDef.field : '')\n  }));\n  return {\n    tooltip: [...fiveSummaryTooltip, // need to cast because TextFieldDef support fewer types of bin\n    ...fieldDefs(encodingWithoutContinuousAxis)]\n  };\n}\nexport function getTitle(continuousAxisChannelDef) {\n  const axis = continuousAxisChannelDef.axis,\n        title = continuousAxisChannelDef.title,\n        field = continuousAxisChannelDef.field;\n  return axis && axis.title !== undefined ? undefined : getFirstDefined(title, field);\n}\nexport function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {\n  const scale = continuousAxisChannelDef.scale,\n        axis = continuousAxisChannelDef.axis;\n  return ({\n    partName,\n    mark,\n    positionPrefix,\n    endPositionPrefix = undefined,\n    extraEncoding = {}\n  }) => {\n    const title = getTitle(continuousAxisChannelDef);\n    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {\n      mark,\n      encoding: Object.assign(Object.assign(Object.assign({\n        [continuousAxis]: Object.assign(Object.assign(Object.assign({\n          field: positionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type\n        }, title !== undefined ? {\n          title\n        } : {}), scale !== undefined ? {\n          scale\n        } : {}), axis !== undefined ? {\n          axis\n        } : {})\n      }, isString(endPositionPrefix) ? {\n        [continuousAxis + '2']: {\n          field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type\n        }\n      } : {}), sharedEncoding), extraEncoding)\n    });\n  };\n}\nexport function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {\n  const clip = markDef.clip,\n        color = markDef.color,\n        opacity = markDef.opacity;\n  const mark = markDef.type;\n\n  if (markDef[part] || markDef[part] === undefined && compositeMarkConfig[part]) {\n    return [Object.assign(Object.assign({}, partBaseSpec), {\n      mark: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, compositeMarkConfig[part]), clip ? {\n        clip\n      } : {}), color ? {\n        color\n      } : {}), opacity ? {\n        opacity\n      } : {}), isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {\n        type: partBaseSpec.mark\n      }), {\n        style: \"\".concat(mark, \"-\").concat(part)\n      }), isBoolean(markDef[part]) ? {} : markDef[part])\n    })];\n  }\n\n  return [];\n}\nexport function compositeMarkContinuousAxis(spec, orient, compositeMark) {\n  const encoding = spec.encoding;\n  const continuousAxis = orient === 'vertical' ? 'y' : 'x';\n  const continuousAxisChannelDef = encoding[continuousAxis]; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n\n  const continuousAxisChannelDef2 = encoding[continuousAxis + '2'];\n  const continuousAxisChannelDefError = encoding[continuousAxis + 'Error'];\n  const continuousAxisChannelDefError2 = encoding[continuousAxis + 'Error2'];\n  return {\n    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),\n    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),\n    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),\n    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),\n    continuousAxis\n  };\n}\n\nfunction filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {\n  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const aggregate = continuousAxisChannelDef.aggregate,\n          continuousAxisWithoutAggregate = __rest(continuousAxisChannelDef, [\"aggregate\"]);\n\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n\n    return continuousAxisWithoutAggregate;\n  } else {\n    return continuousAxisChannelDef;\n  }\n}\n\nexport function compositeMarkOrient(spec, compositeMark) {\n  const mark = spec.mark,\n        encoding = spec.encoding;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        } // default orientation = vertical\n\n\n        return 'vertical';\n      }\n    } // x is continuous but y is not\n\n\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}